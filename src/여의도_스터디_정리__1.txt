여의도 스터디 정리 #1
2013-08-03 21:05:15
#
오늘 스터디에서 공부한 내용을 간략히 정리해보자.

#
aba problem에 대해 과제이었던 counter example을 통해 살펴봄
<a href="http://en.wikipedia.org/wiki/ABA_problem">http://en.wikipedia.org/wiki/ABA_problem</a>에 있는 내용은 상대적으로 난해함
<a href="http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf</a> 내용과 함께 다음 주에 다시 공부할 예정
<a href="/a/context_switching_과_simultaneously_실행.html">context switching 과 simultaneously 실행</a>
<a href="/a/환형큐의_thread_unsafety_문제.html">환형큐의 thread unsafety 문제</a>

#
volatile/interlocked operation/memory barrier
<a href="/a/volatile_과_interlocked_operation.html">volatile 과 interlocked operation</a>
<a href="http://summerlight-textcube.blogspot.kr/2009/11/volatile%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B0%B0%EB%A6%AC%EC%96%B4.html">http://summerlight-textcube.blogspot.kr/2009/11/volatile과-메모리-배리어.html</a>

#
intrusive/non-intrusive
<a href="http://www.makelinux.net/ldd3/chp-11-sect-5">http://www.makelinux.net/ldd3/chp-11-sect-5</a>
<a href="http://www.boost.org/doc/libs/1_54_0/doc/html/intrusive.html">http://www.boost.org/doc/libs/1_54_0/doc/html/intrusive.html</a>
<a href="http://www.boost.org/doc/libs/1_54_0/doc/html/intrusive/intrusive_vs_nontrusive.html">http://www.boost.org/doc/libs/1_54_0/doc/html/intrusive/intrusive_vs_nontrusive.html</a>

#
InterlockedSList
<a href="/a/Interlocked_Singly_Linked_Lists.html">Interlocked Singly Linked Lists</a>

#
Actor model
각 actor 객체에 접근하는 thread는 반드시 하나임을 보장함. context switching 비용을 줄이기 위해 thread 개수를 제한하지만 많은 actor를 다루기 위해 객체별 수행 동기화 기법을 사용한다.
<a href="http://en.wikipedia.org/wiki/Actor_model">http://en.wikipedia.org/wiki/Actor_model</a>
<a href="객체별_함수_수행_동기화.html">객체별 함수 수행 동기화</a>

#
out of order execution
컴파일러의 명령어 재배치 수준이 아닌 cpu 내부의 비순차 실행
비순차 실행을 통해 최대 수행 시간의 절감 효과를 얻음
하드웨어적 한계로 비순차 실행 명령어 window를 유지 (reservation stations), 그 내부에서 각 operand 준비 완료가 되면 연산 수행
operand 준비 완료 통지 연산량 감소를 port grouping, 결과 순서를 보장해주기 위해 rob를 사용
<a href="http://en.wikipedia.org/wiki/Reservation_stations">http://en.wikipedia.org/wiki/Reservation_stations</a>

#
memory consistency model
우리가 작성한 대로 수행을 보장해준다면(Sequentially-consistent ordering) 프로그램의 흐름을 이해하기가 쉽지만 최적화 가능성이 줄어듬. 이를 완화(relaxed)해주어서 최적화가 잘 되게 해보자. 그런데 intel x86-64는 그런거 없음. 
<a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf">http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf</a>

c++11에 memory order로 추가됨.
<a href="http://en.cppreference.com/w/cpp/atomic/memory_order">http://en.cppreference.com/w/cpp/atomic/memory_order</a>

#
c++ threading facilities
<a href="http://en.wikipedia.org/wiki/C%2B%2B11#Threading_facilities">http://en.wikipedia.org/wiki/C%2B%2B11#Threading_facilities</a>
표준에서 지원하기는 하는데, 표준 라이브러리가 어떻게 구현되어있는지 보고 괜찮은지를 판단한 후 사용하자.
<a href="http://board.poolc.org/generation06/1474">async, future, promise in c++</a>

#
sync/async programming
아무튼 async가 흐름 따라가기가 어렵다.
<a href="asynchronous_programming_과_async,_await">asynchronous programming 과 async, await</a>

#
c++11의 lambda
<a href="http://ogoons.tistory.com/69">Visual C++10과 C++0x</a>

#
thread safe한 singleton
<a href="http://board.poolc.org/generation03/512">http://board.poolc.org/generation03/512</a>
근데 intel x86-64에서는 memory barrier 안 쳐줘도 문제가 없다-_-;

하지만 함수 내 static 변수를 반환하는 것만으로도 대충 thread-safe한 singleton이 구현 가능해졌다. c++11부터.
<a href="http://stackoverflow.com/questions/8102125/is-local-static-variable-initialization-thread-safe-in-c11">http://stackoverflow.com/questions/8102125/is-local-static-variable-initialization-thread-safe-in-c11</a>
<a href="http://stackoverflow.com/questions/2280630/c-threadsafe-static-constructor">http://stackoverflow.com/questions/2280630/c-threadsafe-static-constructor</a>

#
기타 windows via c/c++ 내용
CreateThread, SSDT, Kernel object, CriticalSection, ...

#
lock
CAS (InterlockedCompareExchange 사용) 로 쉽게 구현할 수 있다.
reader/writer (shared/exclusive) lock을 사용할 수 있지만 fairness를 잘 고민해야한다.
그냥 lock/unlock 부르지 말고 raii 잘 써서 쓰자.

#
과제 해법
1) lock 사용
2) interlocked-operation 사용
3) counter(actor)에 대해 message passing 사용
