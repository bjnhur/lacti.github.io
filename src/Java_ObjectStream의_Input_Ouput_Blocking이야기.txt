Java ObjectStream의 Input/Ouput Blocking이야기
2010-04-29 20:52:17
Java의 ObjectInputStream / ObjectOutputStream을 사용하여 데이터 통신을 할 때,
Client와 Server 양측에서 ObjectInputStream을 먼저 생성하면 프로그램이 더이상 진행되지 않는 경우가 있는데,
그 이유는 다음과 같다.

ObjectInputStream의 initialize 코드
<pre class="brush: java; html-script: true">    public ObjectInputStream(InputStream in) throws IOException {
        verifySubclass();
        bin = new BlockDataInputStream(in);
        handles = new HandleTable(10);
        vlist = new ValidationList();
        enableOverride = false;
        readStreamHeader();
        bin.setBlockDataMode(true);
    }</pre>

보면, readStreamHeader(); 함수가 호출되는데,
<pre class="brush: java; html-script: true">    protected void readStreamHeader()
        throws IOException, StreamCorruptedException
    {
        short s0 = bin.readShort();
        short s1 = bin.readShort();</pre>

다음과 같이 bin이라는 멤버 변수를 사용하여 short 값 2개를 읽는다. 이 bin이라는 녀석은,
<pre class="brush: java; html-script: true">    /** filter stream for handling block data conversion */
    private final BlockDataInputStream bin;</pre>
와 같은데, 딱 봐도 뭔가 block 시킬 것 같이 무시무시한 이름을 가졌다.

이 때문에 양측에서 먼저 InputStream을 생성하면 둘다 short 값 2개를 서로 기다리다가 프로그램이 진행이 안되는 것.

이것을 해결하기 위해서 ObjectOutputStream을 먼저 생성하는데, 그 이유는 이와 같다.
<pre class="brush: java; html-script: true">    public ObjectOutputStream(OutputStream out) throws IOException {
        verifySubclass();
        bout = new BlockDataOutputStream(out);
        handles = new HandleTable(10, (float) 3.00);
        subs = new ReplaceTable(10, (float) 3.00);
        enableOverride = false;
        writeStreamHeader();
        bout.setBlockDataMode(true);
        if (extendedDebugInfo) {
            debugInfoStack = new DebugTraceInfoStack();
        } else {
            debugInfoStack = null;
        }   
    }</pre>
ObjectOutputStream의 생성 코드를 보면, writeStreamHeader(); 를 호출한다.

<pre class="brush: java; html-script: true">    protected void writeStreamHeader() throws IOException {
        bout.writeShort(STREAM_MAGIC);
        bout.writeShort(STREAM_VERSION);
    }</pre>
여기서는 딱 에누리없이 정의된 short 값 2개를 보내는데, 이것이 바로 MAGIC_NUMBER였던 것이라

이와 같은 작용으로 인해 ObjectStream은 서로 Object를 주고받을 준비가 되었는지(양쪽다 ObjectStream인지) 확인하고 데이터를 주고 받을 수 있는 것이다.

결론.
ObjectInputStream을 양쪽에서 먼저 생성하면 blocking,
따라서 ObjectOutputStream을 먼저 생성해줘야 stream에 값을 write 후, InputStream에서 읽을 수 있으므로 제대로 돌아간다.

끝.
