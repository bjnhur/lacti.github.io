<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title>Java ObjectStream의 Input/Ouput Blocking이야기</title>
    <link href='../res/main.css' rel='stylesheet' type='text/css' />
	<link href="http://yui.yahooapis.com/pure/0.3.0/grids-min.css" rel="stylesheet">
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shCore.css' rel='stylesheet' type='text/css' />
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css' rel='stylesheet' type='text/css' />
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushXml.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJScript.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCSharp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCpp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJava.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushBash.js' type='text/javascript'></script>
  </head>
  <body>
    <div id='title'>
      <h1>Java ObjectStream의 Input/Ouput Blocking이야기</h1>
    </div>
    <div id='content'>
Java의 ObjectInputStream / ObjectOutputStream을 사용하여 데이터 통신을 할 때,<br />
Client와 Server 양측에서 ObjectInputStream을 먼저 생성하면 프로그램이 더이상 진행되지 않는 경우가 있는데,<br />
그 이유는 다음과 같다.<br />
<br />
ObjectInputStream의 initialize 코드<br />
<pre class='brush: java'>    public ObjectInputStream(InputStream in) throws IOException {
        verifySubclass();
        bin = new BlockDataInputStream(in);
        handles = new HandleTable(10);
        vlist = new ValidationList();
        enableOverride = false;
        readStreamHeader();
        bin.setBlockDataMode(true);
    }</pre>
<br />
보면, readStreamHeader(); 함수가 호출되는데,<br />
<pre class='brush: java'>    protected void readStreamHeader()
        throws IOException, StreamCorruptedException
    {
        short s0 = bin.readShort();
        short s1 = bin.readShort();</pre>
<br />
다음과 같이 bin이라는 멤버 변수를 사용하여 short 값 2개를 읽는다. 이 bin이라는 녀석은,<br />
<pre class='brush: java'>    /** filter stream for handling block data conversion */
    private final BlockDataInputStream bin;</pre>
와 같은데, 딱 봐도 뭔가 block 시킬 것 같이 무시무시한 이름을 가졌다.<br />
<br />
이 때문에 양측에서 먼저 InputStream을 생성하면 둘다 short 값 2개를 서로 기다리다가 프로그램이 진행이 안되는 것.<br />
<br />
이것을 해결하기 위해서 ObjectOutputStream을 먼저 생성하는데, 그 이유는 이와 같다.<br />
<pre class='brush: java'>    public ObjectOutputStream(OutputStream out) throws IOException {
        verifySubclass();
        bout = new BlockDataOutputStream(out);
        handles = new HandleTable(10, (float) 3.00);
        subs = new ReplaceTable(10, (float) 3.00);
        enableOverride = false;
        writeStreamHeader();
        bout.setBlockDataMode(true);
        if (extendedDebugInfo) {
            debugInfoStack = new DebugTraceInfoStack();
        } else {
            debugInfoStack = null;
        }   
    }</pre>
ObjectOutputStream의 생성 코드를 보면, writeStreamHeader(); 를 호출한다.<br />
<br />
<pre class='brush: java'>    protected void writeStreamHeader() throws IOException {
        bout.writeShort(STREAM_MAGIC);
        bout.writeShort(STREAM_VERSION);
    }</pre>
여기서는 딱 에누리없이 정의된 short 값 2개를 보내는데, 이것이 바로 MAGIC_NUMBER였던 것이라<br />
<br />
이와 같은 작용으로 인해 ObjectStream은 서로 Object를 주고받을 준비가 되었는지(양쪽다 ObjectStream인지) 확인하고 데이터를 주고 받을 수 있는 것이다.<br />
<br />
결론.<br />
ObjectInputStream을 양쪽에서 먼저 생성하면 blocking,<br />
따라서 ObjectOutputStream을 먼저 생성해줘야 stream에 값을 write 후, InputStream에서 읽을 수 있으므로 제대로 돌아간다.<br />
<br />
끝.<br />

    </div>
    <div id='clear'></div>
  </body>
  <script type='text/javascript'>
    SyntaxHighlighter.all();
  </script>
</html>