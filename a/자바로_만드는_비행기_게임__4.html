<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="blog">
    <meta name="author" content="lacti">

    <title>자바로 만드는 비행기 게임 #4</title>
	<link href="http://yui.yahooapis.com/pure/0.3.0/grids-min.css" rel="stylesheet">
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shCore.css' rel='stylesheet' type='text/css' />
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css' rel='stylesheet' type='text/css' />
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushXml.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJScript.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCSharp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCpp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJava.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushBash.js' type='text/javascript'></script>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.css" rel="stylesheet">

    <!-- Add custom CSS here -->
    <link href="../css/blog-post.css" rel="stylesheet">

</head>

<body>

    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">#</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="#about">About</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <div class="container">

        <div class="row">
            <div class="col-lg-8">

                <!-- the actual blog post: title/author/date/content -->
                <h1>자바로 만드는 비행기 게임 #4</h1>
                <p>
                    <span class="glyphicon glyphicon-time"></span> Posted on November 13, 2011 at 11:29 AM</p>
                <hr>
                <div class="content">
#<br />
이번과 다음은 코드 정리를 해보자.<br />
이전까지의 비행기 게임 코드는 너무 하나의 class 에서 다 처리하는 방식으로,<br />
뭐 하나 수정하기도 좋지 못한 구조였다 (물론 코드 전체가 별로 안 기니까 크게 상관없겠지만)<br />
<br />
예를 들어 적기의 종류를 새로 추가한다던가,<br />
총알의 종류를 새로 추가한다던가 하는 것이 쉽지 않은 코드였다.<br />
<br />
따라서 이번에는 간단하게 코드를 묶으면서 정리를 해보자.<br />
<br />
#<br />
먼저 resource 를 분리하자.<br />
현재 게임에서 사용되고 있는 resource 는 player 의 ship image 와 enemy 의 ship image 이다.<br />
그리고 그것들은 모두 java.awt.Image 형식으로 특정 정보를 가져올 때마다 image observer (media tracker) 를 걸어주는 구조로, 미리 모두 메모리에 올려두는 것과는 좀 다른 방식이다.<br />
<br />
어차피 게임이 한 번 떠서 끝날 때까지 resource 를 내릴 필요가 없으므로,<br />
모든 정보가 메모리에 올라가있는 java.awt.BufferedImage 를 사용하여 resource 를 관리하자.<br />
먼저 resource 의 type 을 정의하자<br />
<pre class="brush: java; html-script: true">enum ResourceType {<br />
    ENEMY_SHIP, PLAYER_SHIP<br />
}</pre><br />
<br />
이제 이 type 에 대해 BufferedImage 를 갖는 manager class 를 만들자.<br />
이 manager class 는 게임 전체에 딱 하나만 존재하면 되므로 singleton 을 사용한다.<br />
<pre class="brush: java; html-script: true">class ResourceManager {<br />
    static ResourceManager instance = new ResourceManager();<br />
    public static ResourceManager getInstance() {<br />
        return instance;<br />
    }<br />
    private Map<ResourceType, BufferedImage> imageMap = new HashMap<ResourceType, BufferedImage>();<br />
    private ResourceManager() {<br />
        try {<br />
            imageMap.put(ResourceType.ENEMY_SHIP, ImageIO.read(getClass().getResource("enemy.png")));<br />
            imageMap.put(ResourceType.PLAYER_SHIP, ImageIO.read(getClass().getResource("player.png")));<br />
        } catch (IOException e) {<br />
            System.err.println("Cannot load resources");<br />
            System.exit(0);<br />
        }<br />
    }<br />
    public BufferedImage getImage(ResourceType type) {<br />
        return imageMap.get(type);<br />
    }<br />
}</pre><br />
<br />
객체가 생성될 때 javax.imageio.ImageIO class 의 helper function 을 사용하여 png 파일을 읽는다.<br />
이 때 굳이 파일을 절대경로로 주지 않고 class loader 의 getResource 함수를 이유는 해당 png 파일을 project 내에 포함시켜서 하나의 jar 로 배포할 때도 동작하게 하기 위함이다.<br />
(따라서 위와 같이 쓰려면 해당 png 파일을 project 디렉토리가 아닌 src 디렉토리에 넣어주어야 한다.)<br />
<br />
생성자를 private 로 만들어서 다른 곳에서의 생성을 막았고,<br />
static 함수로 ResourceManager class 의 단일 객체를 반환하도록 하여 간단히 singleton 을 구현하였다.<br />
<br />
#<br />
그리고 모든 게임 내의 물체에 대한 추상 class 를 만들자.<br />
GameObject 라고 부를 이 class 는 자신의 고유 id 와 충돌 영역을 갖고,<br />
매 tick 마다 어떻게 갱신 (update) 를 할지, 그리고 어떻게 그려져야할 지 (paint) 에 대한 interface 를 갖는다.<br />
<pre class="brush: java; html-script: true">abstract class GameObject {<br />
    private static long idSerial = 0;<br />
    <br />
    protected long id = ++idSerial;<br />
    protected long creationTick = System.currentTimeMillis();<br />
    protected Point2D location = new Point2D.Float();<br />
    protected int width, height;<br />
    public GameObject(int width, int height) {<br />
        this.width = width;<br />
        this.height = height;<br />
    }<br />
    public void setLocation(float x, float y) {<br />
        this.location.setLocation(x, y);<br />
    }<br />
    protected Rectangle2D getBound() {<br />
        return new Rectangle2D.Float((float) location.getX(), (float) location.getY(), width, height);<br />
    }<br />
    public boolean check(GameObject other) {<br />
        if (this == other)<br />
            return false;<br />
        return getBound().intersects(other.getBound());<br />
    }<br />
    public long getId() {<br />
        return id;<br />
    }<br />
    public int getHeight() {<br />
        return height;<br />
    }<br />
    public int getWidth() {<br />
        return width;<br />
    }<br />
    public abstract void paint(Graphics2D g2d);<br />
    public abstract void update();<br />
    public abstract boolean isOutOfScreen(int screenWidth, int screenHeight);<br />
}</pre><br />
<br />
id 는 순차적으로 발급하면 되므로 static 변수의 값을 증가시키면서 얻는다. 이는 추후 총알과 비행기의 충돌검사를 할 때, 자기가 쏜 총알에는 안 맞도록 처리하기 위해 사용된다.<br />
<br />
공용적으로 갖게 되는 위치 (location) 정보와 가로, 세로 길이(width, height) 를 바탕으로 충돌 영역을 반환한느 함수를 가지고 있다 (getBound)<br />
충돌 영역을 계산할 수 있다면, 충돌 검사 함수 (check) 에서는 단순히 두 java.awt.geom.Rectangle2D class 의 intersect 함수를 통해 영역이 겹쳐졌나 확인해볼 수 있다.<br />
(물론 이는 XNA 의 bitmap check 같은 방식은 아니라서 그냥 간단한 사각형 충돌 처리밖에 안된다, 더 자세히 하려면 PathIterator 같은 것을 써서 Polygon 을 구성해서 하면 될 것이다)<br />
<br />
그리고 갱신 (update), 그리기 (paint) 에 대한 interface 를 갖는다.<br />
화면 밖으로 사라졌는지 (isOutOfScreen) 에 대한 interface 는 update 후 자신이 화면 밖으로 나갔다는 것을 판단해서 해당 객체를 없애기 위함인데, 미리 말하자면 위 구조는 별로 깔끔하지 않다. 이는 #5 에서 수정할 예정이다.<br />
<br />
#<br />
이제 이 class 를 상속받아 Ship 에 대한 기본 class 를 만들어보자. Ship class 는 Enemy class 와 Player class 가 상속받게 되는 class 로, 어떤 ship image 를 갖고, 그것을 어떻게 그리는지를 명시한다.<br />
<pre class="brush: java; html-script: true">abstract class Ship extends GameObject {<br />
    private BufferedImage image;<br />
    public Ship(BufferedImage image) {<br />
        super(image.getWidth(), image.getHeight());<br />
        this.image = image;<br />
    }<br />
    public void paint(Graphics2D g2d) {<br />
        int x = (int) Math.round(location.getX() - width / 2);<br />
        int y = (int) Math.round(location.getY() - height / 2);<br />
        g2d.drawImage(image, x, y, null);<br />
    }<br />
    @Override<br />
    protected Rectangle2D getBound() {<br />
        return new Rectangle2D.Float((float) location.getX() - width / 2,<br />
                (float) location.getY() - height / 2, width, height);<br />
    }<br />
}</pre><br />
<br />
Ship class 는 어떤 image 기반으로 동작할지 생성자로 Image 에 대한 정보를 받는다.<br />
그리고 그 image 를 paint 함수에서 그려준다. 이 때 현재 비행기의 위치를 그림의 중앙으로 보정하기 때문에 width / 2, height / 2 를 빼게 된다.<br />
이 때문에 충돌 영역이 바뀌게 되므로 (기존 충돌 영역은 그냥 x, y 였으니까) 충돌 영역을 고쳐서 반환할 수 있도록 해준다.<br />
<br />
#<br />
총알에 대한 class 를 만든다.<br />
<pre class="brush: java; html-script: true">class Bullet extends GameObject {<br />
    public static final int PLAYER = -1;<br />
    public static final int ENEMY = 1;<br />
    private static final int WIDTH = 2;<br />
    private static final int HEIGHT = 5;<br />
    private static final int BULLET_SPEED = 20;<br />
    private int direction;<br />
    private long ownerId;<br />
    public Bullet(long ownerId, int direction) {<br />
        super(WIDTH, HEIGHT);<br />
        this.ownerId = ownerId;<br />
        this.direction = direction;<br />
    }<br />
    @Override<br />
    public boolean check(GameObject other) {<br />
        if (this == other)<br />
            return false;<br />
        if (ownerId == other.getId())<br />
            return false;<br />
        return super.check(other);<br />
    }<br />
    @Override<br />
    public void update() {<br />
        location.setLocation(location.getX(), location.getY() + direction * BULLET_SPEED);<br />
    }<br />
    @Override<br />
    public void paint(Graphics2D g2d) {<br />
        g2d.setColor(Color.gray);<br />
        g2d.fill(getBound());<br />
    }<br />
    @Override<br />
    public boolean isOutOfScreen(int screenWidth, int screenHeight) {<br />
        float minY = (float) location.getY() - height;<br />
        float maxY = (float) location.getY() + height;<br />
        switch (direction) {<br />
        case PLAYER:<br />
            return maxY < 0;<br />
        case ENEMY:<br />
            return minY > screenHeight;<br />
        }<br />
        return true;<br />
    }<br />
}</pre><br />
Player 의 총알은 -y 방향으로 진행하고, Enemy 의 총알은 +y 방향으로 진행하므로 이를 구분하는 값을 -1, 1 과 같이 정의하였다. (당연한 이야기이지만 이는 #5 에서 수정될 구조이다. 딱 봐도 좋지 않다)<br />
<br />
총알을 쏜 ship 과는 충돌을 하면 안되므로 총알을 생성할 때 자신이 누구에 대한 총알인지 owner 의 game object id 를 받는다. 그래서 충돌 검사 함수를 override 하여 owner id 가 해당 game object 의 id 와 같다면 충돌 처리를 하지 않는다.<br />
<br />
그리고 매 update 마다 지정된 속도로 총알이 이동할 수 있도록 하고,<br />
resource 가 없으니까 간단하게 충돌 영역을 회색으로 칠해서 총알을 그려버린다.<br />
<br />
화면에서 총알이 나갔을 때 총알을 메모리에서 없애버려야 하므로 방향에 따라 화면 이탈 여부를 고려해 isOutOfScreen 함수를 작성한다.<br />
<br />
#<br />
Player 의 Ship 은 방향 키에 따라 움직일 수 있다. 따라서 먼저 어떤 방향으로 움직일지에 대한 정보를 enum 으로 만든다.<br />
<pre class="brush: java; html-script: true">enum MoveDirection {<br />
    NONE, LEFT, RIGHT, UP, DOWN;<br />
    public static MoveDirection fromKeyEvent(KeyEvent e) {<br />
        switch (e.getKeyCode()) {<br />
        case KeyEvent.VK_LEFT: return LEFT;<br />
        case KeyEvent.VK_RIGHT: return RIGHT;<br />
        case KeyEvent.VK_UP: return UP;<br />
        case KeyEvent.VK_DOWN: return DOWN;<br />
        }<br />
        return NONE;<br />
    }<br />
}</pre><br />
어차피 방향은 KeyEvent 정보로부터 받게 되므로, enum 내에 KeyEvent 로부터 enum 값을 반환하는 함수를 작성했다.<br />
<br />
Player 의 Ship 은 사용자가 누른 Key 에 대해서 움직이고, 총알을 쏠 수 있다.<br />
<pre class="brush: java; html-script: true">class Player extends Ship {<br />
    private static final int BULLET_Y_POS_MARGIN = 8;<br />
    private static final int SHOT_DELAY = 300;<br />
    private static final int SPEED = 10;<br />
    private long lastShotTick = 0;<br />
    public Player() {<br />
        super(ResourceManager.getInstance().getImage(ResourceType.PLAYER_SHIP));<br />
    }<br />
    @Override<br />
    public void update() {<br />
    }<br />
    public void move(MoveDirection direction) {<br />
        switch (direction) {<br />
        case LEFT: location.setLocation(location.getX() - SPEED, location.getY()); break; <br />
        case RIGHT: location.setLocation(location.getX() + SPEED, location.getY()); break;<br />
        case UP: location.setLocation(location.getX(), location.getY() - SPEED); break;<br />
        case DOWN: location.setLocation(location.getX(), location.getY() + SPEED); break;<br />
        }<br />
    }<br />
    public boolean canShot() {<br />
        return (lastShotTick + SHOT_DELAY < System.currentTimeMillis());<br />
    }<br />
    public Bullet shot() {<br />
        lastShotTick = System.currentTimeMillis();<br />
        Bullet bullet = new Bullet(getId(), Bullet.PLAYER);<br />
        bullet.setLocation((float) location.getX(), (float) location.getY() - height / 2 - BULLET_Y_POS_MARGIN);<br />
        return bullet;<br />
    }<br />
    @Override<br />
    public boolean isOutOfScreen(int screenWidth, int screenHeight) {<br />
        return false;<br />
    }<br />
    public static Player create(int screenWidth, int screenHeight) {<br />
        Player player = new Player();<br />
        player.setLocation(screenWidth / 2, screenHeight * 2 / 3);<br />
        return player;<br />
    }<br />
}</pre><br />
먼저 생성할 때 ResourceManager 로부터 PlayerShip image resource 를 가져와서 Ship class 의 생성자로 넣어준다.<br />
move 함수에서는 어떤 방향으로 움직일 지에 대해 지정된 값으로 더해서 이동할 수 있도록 한다.<br />
<br />
총알은 지정된 shot delay 가 넘지 않았다면 쏠 수 없다. 따라서 canShot 함수에서 이 tick 이 넘었는지 검사하고,<br />
shot 함수에서 총알을 만들어서 반환한다. (여기도 수정 대상이다)<br />
<br />
Player 는 매 tick 마다 현재 해줄 일이 없으므로 update 함수는 그냥 비워둔다.<br />
Player 를 만드는 create 함수가 static 으로 선언되어있는데, 현재는 별 의미 없는 함수이다.<br />
<br />
#<br />
마지막으로 적기에 대한 class 를 만들어 보자.<br />
<pre class="brush: java; html-script: true">class Enemy extends Ship {<br />
    private static final int SPAWN_BASE_TICK = 500;<br />
    private static final int SPAWN_RANDOM_TICK = 2000;<br />
    private static final int BULLET_Y_POS_MARGIN = 8;<br />
    private static final int RANDOM_LIFETIME = 50;<br />
    private static final int BASE_LIFETIME = 50;<br />
    private static long spawnTick;<br />
    <br />
    private Point2D moveDelta = new Point2D.Float();<br />
    public Enemy(Point2D location, Point2D moveDelta) {<br />
        super(ResourceManager.getInstance().getImage(ResourceType.ENEMY_SHIP));<br />
        this.location.setLocation(location);<br />
        this.moveDelta.setLocation(moveDelta);<br />
    }<br />
    @Override<br />
    public void update() {<br />
        location.setLocation(location.getX() + moveDelta.getX(), <br />
                location.getY() + moveDelta.getY());<br />
    }<br />
    public boolean canShot() {<br />
        return (Math.random() < 0.2);<br />
    }<br />
    public Bullet shot() {<br />
        Bullet bullet = new Bullet(getId(), Bullet.ENEMY);<br />
        bullet.setLocation((float) location.getX(), (float) location.getY() + height / 2 + BULLET_Y_POS_MARGIN);<br />
        return bullet;<br />
    }<br />
    @Override<br />
    public boolean isOutOfScreen(int screenWidth, int screenHeight) {<br />
        float minX = (float) location.getX() - width / 2;<br />
        float minY = (float) location.getY() - height / 2;<br />
        return minX > screenWidth || minY > screenHeight;<br />
    }<br />
    public static boolean isSpawnable() {<br />
        return spawnTick < System.currentTimeMillis();<br />
    }<br />
    public static Enemy spawn(int screenWidth, int screenHeight) {<br />
        spawnTick = System.currentTimeMillis() + new Random().nextInt(SPAWN_RANDOM_TICK) + SPAWN_BASE_TICK;<br />
        Random rand = new Random();<br />
        int shipHeight = ResourceManager.getInstance().getImage(ResourceType.ENEMY_SHIP).getHeight();<br />
        float lifetime = rand.nextFloat() * RANDOM_LIFETIME + BASE_LIFETIME;<br />
        int startX = rand.nextInt(screenWidth);<br />
        int endX = rand.nextInt(screenWidth);<br />
        Point2D location = new Point2D.Float(startX, -1 * shipHeight);<br />
        Point2D moveDelta = new Point2D.Float((endX - startX) / lifetime, (screenHeight + shipHeight * 2) / lifetime);<br />
        return new Enemy(location, moveDelta);<br />
    }<br />
}</pre><br />
<br />
적기의 logic 은 이전 코드에서 그대로 가져온 것으로, 처음 시작 위치 (location) 과 매 tick 마다 update 에서 더해줄 이동 값 (moveDelta) 을 생성자로 받는다.<br />
이것도 역시 canShot 과 shot 함수를 통해 총알을 발사하게 된다.<br />
<br />
적기를 spawn 하는 시점과 어떤 위치에서 적기를 만들지에 대한 함수를 static 으로 갖는다.<br />
<br />
#<br />
이제 main class 를 정리해보자.<br />
기존에는 각 type 에 대한 List 를 가지고 있었어야 했지만, 이제는 GameObject 로 이루어진 container 하나만 있으면 된다.<br />
<pre class="brush: java; html-script: true">private Player player = Player.create(WIDTH, HEIGHT);<br />
private List<GameObject> objects = new ArrayList<GameObject>();</pre><br />
대신, Player 의 경우는 move 함수 등을 직접 조작해주어야 하니까 따로 reference 를 갖는다.<br />
하지만 이것도 update 함수나 paint 함수가 불리어야 하므로 objects 안에 넣어준다.<br />
<pre class="brush: java; html-script: true">public Tatieul() {<br />
    setPreferredSize(new Dimension(WIDTH, HEIGHT));<br />
    setFocusable(true);<br />
    addKeyListener(this);<br />
    new Timer(100, this).start();<br />
    objects.add(player);<br />
}</pre><br />
<br />
Key 를 눌렀을 때는 Player 객체의 move 함수를 불러주면 된다. 단 VK_SPACE 를 눌렀다면 총알을 만들어서 objects 에 넣어준다.<br />
<pre class="brush: java; html-script: true">public void keyPressed(KeyEvent e) {<br />
    switch (e.getKeyCode()) {<br />
    case KeyEvent.VK_UP:<br />
    case KeyEvent.VK_DOWN:<br />
    case KeyEvent.VK_LEFT:<br />
    case KeyEvent.VK_RIGHT:<br />
        player.move(MoveDirection.fromKeyEvent(e));<br />
        break;<br />
        <br />
    case KeyEvent.VK_SPACE:<br />
        if (player.canShot())<br />
            objects.add(player.shot());<br />
        break;<br />
    }<br />
    repaint();<br />
}</pre><br />
<br />
매 tick 마다는 모든 객체의 위치를 갱신하고, 충돌 검사를 하며, 적기를 만들어내는 코드는, 실제 수행하는 부분이 모두 각 class 로 빠졌으므로 단순해진다.<br />
<pre class="brush: java; html-script: true">public void actionPerformed(ActionEvent e) {<br />
    updateAll();<br />
    checkCollision();<br />
    generateEnemyAndBullet();<br />
    repaint();<br />
}<br />
private void updateAll() {<br />
    for (GameObject each: objects)<br />
        each.update();<br />
}<br />
private void checkCollision() {<br />
    Set<GameObject> removal = new HashSet<GameObject>();<br />
    for (int i = 0; i < objects.size() - 1; ++i) {<br />
        GameObject lhs = objects.get(i);<br />
        for (int j = i + 1; j < objects.size(); ++j) {<br />
            GameObject rhs = objects.get(j);<br />
            if (!lhs.check(rhs)) continue;<br />
            removal.add(lhs);<br />
            removal.add(rhs);<br />
            break;<br />
        }<br />
    }<br />
    for (GameObject each: objects)<br />
        if (each.isOutOfScreen(getWidth(), getHeight()))<br />
            removal.add(each);<br />
            <br />
    for (GameObject each: removal)<br />
        objects.remove(each);<br />
}<br />
private void generateEnemyAndBullet() {<br />
    if (Enemy.isSpawnable())<br />
        objects.add(Enemy.spawn(getWidth(), getHeight()));<br />
    List<GameObject> bullets = new ArrayList<GameObject>();<br />
    for (GameObject each: objects) {<br />
        if (!(each instanceof Enemy))<br />
            continue;<br />
        Enemy enemy = (Enemy) each;<br />
        if (enemy.canShot())<br />
            bullets.add(enemy.shot());<br />
    }<br />
    objects.addAll(bullets);<br />
}</pre><br />
<br />
모든 object 의 update 는 단순히 objects 의 객체를 순회하면서 update 를 불러주는 것으로 가능하다.<br />
충돌 검사도, 각 case 마다 따로 순회하는 것이 아니라 objects 내의 원소들 간의 충돌을 검사해주는 식으로 통합되었다.<br />
적기를 만드는 과정은 역시 static 함수를 호출해주는 것으로 가능한데,<br />
<br />
적기의 총알을 만드는 것은, GameObject 가 Enemy class 일 때 그 enemy 가 총알을 만들 수 있으면 일단 다른 container 에 모아놨다가 순회가 끝난 후 objects 에 넣어주는 방식이다.<br />
(그냥 objects 를 순회하면서 생성되는 총알을 objects 에 넣어버리면 당연한 이야기지만 ConcurrentModificationException 이 발생한다. 어떤 container 를 순회하는 도중에는 그 container 를 수정[add/remove 등] 할 수 없다)<br />
(총알을 만드는 부분 역시 #5 에서의 리팩토링 대상이다)<br />
<br />
이 모든 것을 화면에 그려주는 것도 단순히 objects 를 한 번 순회하면서 paint 를 불러주면 그만이다.<br />
<pre class="brush: java; html-script: true">public void paintComponent(Graphics g) {<br />
    Graphics2D g2d = (Graphics2D) g;<br />
    g.setColor(Color.white);<br />
    g.fillRect(0, 0, getWidth(), getHeight());<br />
    for (GameObject each: objects)<br />
        each.paint(g2d);<br />
}</pre><br />
<br />
이 때 굳이 Graphics2D 객체로 Graphics 객체를 casting 한 이유는 나중에 여러가지 것들을 써먹기 위함이다.<br />
<br />
#<br />
간단하게 class 를 쪼개고 묶음으로써 코드가 어느정도 정리가 되었다. (물론 덕분에 길어졌다)<br />
코드 내에 박혀있는 숫자를 상수로 바꾸고, class 를 분할하다 보면 어떤 기능이 어느 지점에 추가해야할지 보다 명확히 보일 수 있으므로 그러한 습관을 들이면서 코딩 연습을 하는 것이 좋다.<br />
<br />
미리 예고 했던 대로 #5 까지는 좀 더 리팩토링을 진행하고, #6 부터 키 입력 개선, 미사일 다양화 등 게임 컨텐츠에 집중해보도록 하겠다.<br />

				</div>
                <hr>

                <!-- the comments -->
				<div id="disqus_thread"></div>
				<script type="text/javascript">
					/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
					var disqus_shortname = 'lacti'; // required: replace example with your forum shortname

					/* * * DON'T EDIT BELOW THIS LINE * * */
					(function() {
						var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
						dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
						(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
					})();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
				<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

            </div>

            <div class="col-lg-4">

                <div class="well">
					<h4>Related</h4>
					<ul>
						<li><a href="/a/자바로_만드는_비행기_게임__1.html">자바로 만드는 비행기 게임 #1</a> <span class="date">9. 21.</span></li>
						<li><a href="/a/자바로_만드는_비행기_게임__2.html">자바로 만드는 비행기 게임 #2</a> <span class="date">9. 22.</span></li>
						<li><a href="/a/자바로_만드는_비행기_게임__3.html">자바로 만드는 비행기 게임 #3</a> <span class="date">11. 6.</span></li>
					</ul>
                </div>
                <!-- /well -->
                <div class="well">
					<h4>Recents <a href="/" class="show-all">(all)</a></h4>
					<ul>

						<li><a href="/a/패킷_enum에_따른_packet_콜백_함수_자동생성.html">패킷 enum에 따른 packet 콜백 함수 자동생성</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴__2.html">비동기 프로그래밍 패턴 #2</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴.html">비동기 프로그래밍 패턴</a> <span class="date">10. 9.</span></li>
						<li><a href="/a/websocket,_webRTC.html">websocket, webRTC</a> <span class="date">9. 7.</span></li>
						<li><a href="/a/여의도_스터디_정리__4.html">여의도 스터디 정리 #4</a> <span class="date">8. 26.</span></li>
						<li><a href="/a/여의도_스터디_정리__3.html">여의도 스터디 정리 #3</a> <span class="date">8. 18.</span></li>
						<li><a href="/a/여의도_스터디_과제_풀이__2.html">여의도 스터디 과제 풀이 #2</a> <span class="date">8. 12.</span></li>
					</ul>
                </div>
                <!-- /well -->
				<gcse:search></gcse:search>
            </div>
        </div>

        <hr>

        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; lacti 2014</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- JavaScript -->
    <script src="../js/jquery-1.10.2.js"></script>
    <script src="../js/bootstrap.js"></script>

	<script type='text/javascript'>
		SyntaxHighlighter.all();
	</script>

	<script>
	  (function() {
		var cx = '001870890642618183212:k8iqprsstre';
		var gcse = document.createElement('script');
		gcse.type = 'text/javascript';
		gcse.async = true;
		gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
			'//www.google.com/cse/cse.js?cx=' + cx;
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(gcse, s);
	  })();
	</script>
</body>

</html>
