<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="blog">
    <meta name="author" content="lacti">

    <title>멤버 데이터 포인터를 사용하여 연산식 묶어내기 #2</title>
	<link href="http://yui.yahooapis.com/pure/0.3.0/grids-min.css" rel="stylesheet">
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shCore.css' rel='stylesheet' type='text/css' />
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css' rel='stylesheet' type='text/css' />
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushXml.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJScript.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCSharp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCpp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJava.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushBash.js' type='text/javascript'></script>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.css" rel="stylesheet">

    <!-- Add custom CSS here -->
    <link href="../css/blog-post.css" rel="stylesheet">

</head>

<body>

    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">#</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="#about">About</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <div class="container">

        <div class="row">
            <div class="col-lg-8">

                <!-- the actual blog post: title/author/date/content -->
                <h1>멤버 데이터 포인터를 사용하여 연산식 묶어내기 #2</h1>
                <p>
                    <span class="glyphicon glyphicon-time"></span> Posted on October 03, 2012 at 2:23 AM</p>
                <hr>
                <div class="content">
<a href="http://board.poolc.org/generation06/1570">멤버 데이터 포인터를 사용하여 연산식 묶어내기 #1</a><br />
<br />
#<br />
#2를 바로 쓰지 않고 기다린 이유는, 댓글을 얻기 위함이었다!<br />
#2에서는 Stat 자료구조 내에 배열이 있을 때 이를 어떻게 처리할지에 대해서 알아보도록 하자.<br />
<br />
#<br />
Stat 코드를 작성하다보니, 이동 속도에 관해서는 각각의 변수를 따로 두는 것 보다, 배열 하나로 처리하는 것이 더 낫다는 것을 깨닫게 되었다.<br />
<pre class='brush: cpp'>enum MovingStatType {
    MST_WALK,
    MST_RUN,
    MST_RIDE,
    MST_MAX
};
struct Stat {
    float hp;
    float movingSpeed[MST_MAX];</pre>
배열로 묶어서 movingSpeed 관련 코드가 개선된 것까지는 좋았는데 hp와 movingSpeed는 type이 다르기 때문에 #1의 방법을 더 이상 사용할 수 없게 되었다. 둘의 type을 비교해보면 아래와 같다.<br />
<pre class='brush: cpp'>typedef float Stat::*DataPtr;
typedef float (Stat::*ArrayPtr)[3];</pre>
<br />
어쨌든 두 타입이 완전히 달라졌기 때문에, 이를 일치시키지 못한다면 또 다시 switch-case의 지옥을 맛보게 될 것이다.<br />
멤버 데이터 포인터 수준에서는 이를 해결할 수 없기 때문에 <strong>멤버 함수 포인터</strong>를 사용하여 문제를 해결 할 것이다.<br />
<br />
#<br />
목표는 그냥 멤버 변수와 배열 멤버 변수의 <strong>접근 interface를 통일시키는 것</strong>이다.<br />
멤버 함수 포인터를 사용할 것이니 함수의 signature는 같아야 한다는 것이다.<br />
<br />
위 Stat 구조체에서는 다음과 같이 생각해볼 수 있다.<br />
<pre class='brush: cpp'>struct Stat {
    float& Hp() { return hp; }
    float& WalkSpeed() { return movingSpeed[MST_WALK]; }
    float& RunSpeed() { return movingSpeed[MST_RUN]; }
    float& RideSpeed() { return movingSpeed[MST_RIDE]; }</pre>
이제 위 함수들은 다음의 멤버 함수 포인터로 지칭이 가능하다.<br />
<pre class='brush: cpp'>typedef float& (Stat::*Accessor)();</pre>
<br />
하지만 모든 멤버 변수에 대해서 저렇게 함수를 만들어주는 것은 여간 고역이 아니다.<br />
이런 일을 사람이 하는 것은 예의에 어긋나니, 컴파일러를 부려먹자.<br />
<pre class='brush: cpp'>struct Stat {
    float& Hp() { return hp; }
    template <int _Index>
    float& MovingSpeed() { return movingSpeed[_Index]; }</pre>
template 함수를 사용해서 배열의 인자를 template으로 넘겼다. 저 _Index 값으로 MST_WALK 등의 값을 넘기면 그에 해당하는 MovingSpeed<> 함수를 컴파일러가 알아서 생성해줄 것이다.<br />
<br />
<strong>이렇게 생성된 template 함수들의 interface도 위에서 정의한 Accessor에 부합된다. 이것이 핵심 아이디어이다.</strong><br />
<pre class='brush: cpp'>Accessor acc1 = &Stat::MovingSpeed<MST_WALK>;
Accessor acc2 = &Stat::MovingSpeed<MST_RUN>;</pre>
<br />
#<br />
Stat의 각 멤버에 대해 노출 함수를 만들어주는 것은 지겨운 일이다. 이 함수들 역시 template으로 묶어보자.<br />
<pre class='brush: cpp'>struct Stat {
    template <float Stat::*_DataPtr>
    float& Access() { return this->*_DataPtr; }</pre>
Access 함수는 멤버 데이터 포인터를 template 인자로 받는다. 이 역시 위에서 정의한 Accessor 타입에 부합된다.<br />
<pre class='brush: cpp'>Accessor acc3 = Stat::Access<&Stat::hp>;</pre>
<br />
배열의 멤버 데이터 포인터를 template 인자로 받으려면 약간 까다로운데,<br />
그 이유는 배열의 멤버 데이터 포인터의 타입을 명시할 때에는 그 배열의 크기가 필요하기 때문이다.<br />
<pre class='brush: cpp'>struct Stat {
    template <size_t _Size, float (Stat::*_ArrayPtr)[_Size], int _Index>
    float& Access() { return (this->*_ArrayPtr)[_Index]; }</pre>
배열 타입 명시를 위한 배열의 크기, 멤버 데이터 포인터 값, 그리고 배열 내의 index. 이렇게 3개의 template 인자를 받는다. 이 함수를 사용하여 acc1, acc2를 다시 정의해 본다면 다음과 같다.<br />
<pre class='brush: cpp'>Accessor acc1 = &Stat::Access<MST_MAX, &Stat::movingSpeed, MST_WALK>;
Accessor acc2 = &Stat::Access<MST_MAX, &Stat::movingSpeed, MST_RUN>;</pre>
<br />
이제 일반적인 <strong>Access</strong>라는 멤버 함수를 사용하여 모든 멤버를 접근할 수 있게 되었다.<br />
하지만 이미 선언할 때 명시해준 배열의 크기를 또 적어주어야 하는 것은 마음에 들지 않는다. 이를 고쳐보자.<br />
<br />
#<br />
배열의 크기를 구하기 위해 간단한 메타 템플릿 함수를 작성해보자.<br />
일단 일반적인 interface를 선언하고,<br />
<pre class='brush: cpp'>template <typename T>
struct countof;</pre>
그리고 배열의 크기를 알아내기 위한 특수화된specialization 메타 템플릿 함수를 작성한다.<br />
<pre class='brush: cpp'>template <typename _Ty, typename _Class, size_t _Size>
struct countof<_Ty (_Class::*)[_Size]> {
    enum { value = _Size };
};</pre>
<br />
countof의 타입 argument가 <strong>_Ty (_Class::*)[_Size]</strong> 형태이면 그 _Size를 value로 갖는 메타 템플릿 함수이다. <strong>decltype 키워드</strong>를 사용하여 멤버 데이터 포인터의 타입을 얻을 수 있으므로, 다음과 같이 멤버 데이터 포인터가 가리키는 배열의 크기를 얻을 수 있다.<br />
<pre class='brush: cpp'>countof<decltype(&Stat::movingSpeed)>::value</pre>
<br />
이제 위 배열 멤버에 대한 접근을 다음과 같이 표현할 수 있게 되었다.<br />
<pre class='brush: cpp'>Accessor acc1 = &Stat::Access<countof<decltype(&Stat::movingSpeed)>::value,
    &Stat::movingSpeed, MST_WALK>;</pre>
<br />
#<br />
모든 준비가 갖추어졌다.<br />
멤버의 데이터 타입이 배열이든, 그렇지 않든 float& (Stat::*)() signature를 사용하여 값을 얻을 수 있게 되었다.<br />
<br />
이제 #1에서 했던 방법처럼 코드를 정리하면 된다.<br />
<pre class='brush: cpp'>typedef float& (Stat::*StatAccessor)();
StatAccessor statAccessorTable[BUFF_MAX];
 
statAccessorTable[BUFF_HP] = &Stat::Access<&Stat::hp>;
statAccessorTable[BUFF_WALK_SPEED] = &Stat::Access<countof<decltype(&Stat::movingSpeed)>::value,
    &Stat::movingSpeed, MST_WALK>;</pre>
<br />
<pre class='brush: cpp'>StatAccessor accessor = statAccessorTable[buffType];
switch (buffMethod) {
case SET: (stat.*accessor)() = buffValue; break;
case ADD: (stat.*accessor)() += buffValue; break;
case RATE: (stat.*accessor)() *= buffValue; break;</pre>
<br />
AccessorTable을 등록할 때, 아무래도 배열 타입을 등록하는데 코드가 쓸데없이 길어진다.<br />
이는 매크로를 사용하여 깔끔하게 정리할 수 있겠다.<br />
<pre class='brush: cpp'>// buff_type.inl
BUFF_ENUM(BUFF_HP, &Stat::hp)
BUFF_ENUM_A(BUFF_WALK_SPEED, &Stat::movingSpeed, MST_WALK)</pre>
<br />
<pre class='brush: cpp'>// buff_bind.cpp
#define BUFF_ENUM(name, ptr) statAccessorTable[name] = &Stat::Access<ptr>;
#define BUFF_ENUM_A(name, ptr, idx) \
    statAccessorTable[name] = &Stat::Access<countof<decltype(ptr)>::value, ptr, idx>;
#include "buff_type.inl"
#undef BUFF_ENUM_A
#undef BUFF_ENUM</pre>
<br />
#<br />
본 글에서는 완전히 일치하지는 않지만 어느 정도 타입이 비슷할 때, 멤버 데이터 포인터가 아닌 <strong>template 인자를 활용한 멤버 함수로 signature를 맞추어 반복되는 코드의 양을 줄이는 방법</strong>에 대해 알아보았다.<br />
<br />
지난 번 글에서도 언급했지만, 이것이 가능했던 이유는 각 멤버들이 모두 float 이었기 때문이다.<br />
다음 글에서는 type erasure를 사용하여 좀 더 일반적인 (하지만 성능에서는 손해를 보는) 방법에 대해 알아보도록 하겠다.<br />

				</div>
                <hr>

                <!-- the comments -->
				<div id="disqus_thread"></div>
				<script type="text/javascript">
					/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
					var disqus_shortname = 'lacti'; // required: replace example with your forum shortname

					/* * * DON'T EDIT BELOW THIS LINE * * */
					(function() {
						var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
						dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
						(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
					})();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
				<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

            </div>

            <div class="col-lg-4">

                <div class="well">
					<h4>Related</h4>
					<ul>
						<li><a href="/a/멤버_데이터_포인터를_사용하여_연산식_묶어내기__1.html">멤버 데이터 포인터를 사용하여 연산식 묶어내기 #1</a> <span class="date">10. 1.</span></li>
						<li><a href="/a/멤버_데이터_포인터를_사용하여_연산식_묶어내기__3.html">멤버 데이터 포인터를 사용하여 연산식 묶어내기 #3</a> <span class="date">10. 7.</span></li>
					</ul>
                </div>
                <!-- /well -->
                <div class="well">
					<h4>Recents <a href="/" class="show-all">(all)</a></h4>
					<ul>

						<li><a href="/a/패킷_enum에_따른_packet_콜백_함수_자동생성.html">패킷 enum에 따른 packet 콜백 함수 자동생성</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴__2.html">비동기 프로그래밍 패턴 #2</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴.html">비동기 프로그래밍 패턴</a> <span class="date">10. 9.</span></li>
						<li><a href="/a/websocket,_webRTC.html">websocket, webRTC</a> <span class="date">9. 7.</span></li>
						<li><a href="/a/여의도_스터디_정리__4.html">여의도 스터디 정리 #4</a> <span class="date">8. 26.</span></li>
						<li><a href="/a/여의도_스터디_정리__3.html">여의도 스터디 정리 #3</a> <span class="date">8. 18.</span></li>
						<li><a href="/a/여의도_스터디_과제_풀이__2.html">여의도 스터디 과제 풀이 #2</a> <span class="date">8. 12.</span></li>
					</ul>
                </div>
                <!-- /well -->
				<gcse:search></gcse:search>
            </div>
        </div>

        <hr>

        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; lacti 2014</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- JavaScript -->
    <script src="../js/jquery-1.10.2.js"></script>
    <script src="../js/bootstrap.js"></script>

	<script type='text/javascript'>
		SyntaxHighlighter.all();
	</script>

	<script>
	  (function() {
		var cx = '001870890642618183212:k8iqprsstre';
		var gcse = document.createElement('script');
		gcse.type = 'text/javascript';
		gcse.async = true;
		gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
			'//www.google.com/cse/cse.js?cx=' + cx;
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(gcse, s);
	  })();
	</script>
</body>

</html>
