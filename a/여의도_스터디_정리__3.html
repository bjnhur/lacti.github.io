<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="blog">
    <meta name="author" content="lacti">

    <title>여의도 스터디 정리 #3</title>
	<link href="http://yui.yahooapis.com/pure/0.3.0/grids-min.css" rel="stylesheet">
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shCore.css' rel='stylesheet' type='text/css' />
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css' rel='stylesheet' type='text/css' />
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushXml.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJScript.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCSharp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCpp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJava.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushBash.js' type='text/javascript'></script>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.css" rel="stylesheet">

    <!-- Add custom CSS here -->
    <link href="../css/blog-post.css" rel="stylesheet">

</head>

<body>

    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">#</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="#about">About</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <div class="container">

        <div class="row">
            <div class="col-lg-8">

                <!-- the actual blog post: title/author/date/content -->
                <h1>여의도 스터디 정리 #3</h1>
                <p>
                    <span class="glyphicon glyphicon-time"></span> Posted on August 18, 2013 at 12:29 PM</p>
                <hr>
                <div class="content">
#<br />
오늘 스터디에서 공부한 내용을 간단히 정리해보자.<br />
<br />
#<br />
future, promise는 비동기로 실행되는 수행 결과를 받아오기 위한 개념이다.<br />
<a href="http://en.cppreference.com/w/cpp/thread/future">http://en.cppreference.com/w/cpp/thread/future</a><br />
<br />
async,는 내부적으로 promise를 사용하여 결과를 set()할 비동기 작업을 수행시키고, future를 반환한다.<br />
<a href="http://en.cppreference.com/w/cpp/thread/async">http://en.cppreference.com/w/cpp/thread/async</a><br />
<br />
packaged_task는 비동기 작업을 수행할 수 있는 task 객체를 만들어준다. task 객체로부터 future를 가져올 수 있다.<br />
<a href="http://en.cppreference.com/w/cpp/thread/packaged_task">http://en.cppreference.com/w/cpp/thread/packaged_task</a><br />
<br />
vs2012 기준으로 내부 구현 분석한 내용.<br />
<a href="http://board.poolc.org/generation06/1474">async, future, promise in c++</a><br />
<br />
vs2012 쪽 문제인지 std::async를 수행할 때 std::launch enum 값을 주지 않으면 std::launch::any로 수행하게 되는데 이 때 deferred로 수행되면서 future를 통해 값을 가져오는데 문제가 발생하는 것 같다. 내가 개념을 잘못 이해하고 있는 것인지 모르겠는데 문제가 발생하지 않으려면 std::launch::async로 policy를 주고 실행해야 할 듯<br />
<a href="http://stackoverflow.com/questions/9389409/vs-11-with-stdfuture-is-this-a-bug>http://stackoverflow.com/questions/9389409/vs-11-with-stdfuture-is-this-a-bug</a><br />
<br />
#<br />
spawn<br />
<a href="http://en.wikipedia.org/wiki/Cilk">http://en.wikipedia.org/wiki/Cilk</a><br />
fork/join<br />
<a href="http://minjang.egloos.com/834885>http://minjang.egloos.com/834885</a><br />
<a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html>http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html</a><br />
<br />
상호 의존관계가 없는 작업 집합을 실행할 때, 작업 구간을 여러 개로 나누고(partitioning), 해당 작업을 수행할 작업자(thread)를 만들어서(spawn/fork) 동시에 작업이 수행되도록 한다.<br />
그리고 모든 작업자의 작업이 완료될 때까지 기다려서(join) 그 결과를 하나로 합친다.<br />
<br />
#<br />
c# async/await<br />
비동기 작업을 위해 작업을 수행할 Task를 만든다.<br />
해당 Task가 완료되면 다음 작업을 수행할 수 있도록 Task를 엮는다(Task Continuation)<br />
<a href="http://msdn.microsoft.com/en-us/library/dd460717.aspx">http://msdn.microsoft.com/en-us/library/dd460717.aspx</a><br />
<br />
특정 Task의 결과를 획득할 수 있을 때까지 대기한다. 이 때 할 수 있는 다른 일이 있다면 찾아본다.(await)<br />
이는 단순히 compiler가 await하는 코드들을 하나의 state machine으로 묶어서 state를 변화시키면서 해당 함수를 계속 부럴주는 방식으로 만들어주는 것이다.<br />
<a href="http://weblogs.asp.net/dixin/archive/2012/11/02/understanding-c-async-await-1-compilation.aspx">http://weblogs.asp.net/dixin/archive/2012/11/02/understanding-c-async-await-1-compilation.aspx</a><br />
<br />
실제 코드가 각각 어떤 thread에서 수행될 수 있는지에 대해서는 약간 복잡할 수 있는데 이에 대해서는 다루지 않았다.<br />
요약하면, 비동기 logic을 동기적으로 작성하기 위한 async/await는 결과적으로 state machine code로 compiler에 의해 변환되어 .net thread-pool에 들어갔다 나왔다하면서 코드가 수행된다는 것.<br />
<br />
아래와 같이 코드가 작성되면 연결되는 모든 connection에 대해서 결과를 console에 출력해줄 수 있다.<br />
<pre class="brush: csharp; html-script: true">async void Listen() {<br />
    var serverSocket = new Socket(...);<br />
    Socket clientSocket;<br />
    while ((clientSocket = await serverSocket.AcceptAsync()) != null)<br />
        ProcessSocket(clientSocket);<br />
}<br />
async void ProcessSocket(Socket clientSocket) {<br />
    string line;<br />
    while ((line = await clientSocket.ReadLineAsync()) != null)<br />
        await Console.WriteLineAsync(line);<br />
}</pre><br />
약간 설명을 추가하면, serverSocket.AcceptAsync() 함수를 await할 때 Listen StateMachine이 accept completion state를 대기. accept에 성공한 후 ProcessSocket StateMachine이 read line completion state를 대기. 그런데 Listen StateMachine과 ProcessSocket StateMachine은 await하는 관계가 없으므로 서로 다른 Task가 되어 동시에 Accept도 하고 ReadLine도 할 수 있는 것이다. (즉 작업 흐름 단위가 아니라 Task 단위)<br />
<br />
#<br />
coroutine<br />
<a href="http://en.wikipedia.org/wiki/Coroutine">http://en.wikipedia.org/wiki/Coroutine</a><br />
<a href="http://en.wikipedia.org/wiki/Generator_(computer_science)">http://en.wikipedia.org/wiki/Generator_(computer_science)</a><br />
<a href="http://www.unitystudy.net/bbs/board.php?bo_table=writings&wr_id=43">http://www.unitystudy.net/bbs/board.php?bo_table=writings&wr_id=43</a><br />
정의 자체가 [allow multiple entry points for suspending and resuming execution at certain locations] 이기 때문에 가장 낮은 수준에서 생각해보면 cpu context를 마음대로 치환할 수 있으면 coroutine을 쉽게 만들 수 있겠다! (user mode context switching)<br />
boost는 boost context를 먼저 만들어서 cpu context를 capture할 수 있게 한 다음 그것을 사용해서 boost coroutine을 만들었다. (windows에서는 fiber를 쓴다고 알고 있다)<br />
<br />
그런데 그런 구현 방법 뿐만 아니라 generator를 이용해서 대충 coroutine처럼 사용할 수 있도록 할 수도 있다. c#의 yield return이 그런 형태인데, 이건 그냥 compiler가 해당 코드를 state machine으로 만들어서 다시 부르면 다음 코드부터 이어서 실행될 수 있도록 만들어 주는 것.<br />
<pre class="brush: csharp; html-script: true">IEnumerable<int> MyGenerator() {<br />
    /* do something 1 */<br />
    yield return /* first value */;<br />
    /* do something 2 */<br />
    yield return /* second value */;<br />
    /* do something 3 */<br />
    yield return /* third value */;<br />
    /* do something 4 */<br />
    yield return /* forth value */;<br />
}</pre><br />
<pre class="brush: csharp; html-script: true">struct MyGeneratorStateMachine {<br />
    public int Current { get; set; }<br />
    public bool MoveNext() {<br />
        switch (_state) {<br />
        case 0: /* do something 1 */ Current = /* first value */; _state = 1; return true;<br />
        case 1: /* do something 2 */ Current = /* second value */; _state = 2; return true;<br />
        case 2: /* do something 3 */ Current = /* third value */; _state = 3; return true;<br />
        case 3: /* do something 4 */ Current = /* forth value */; _state = -1; return false;<br />
        }<br />
        return false;<br />
    }</pre><br />
첫 번째 코드로 작성하면 compiler가 두 번째 코드로 알아서 만들어준다는 것.<br />
그러면 함수 호출자에서는 MyGeneratorStateMachine 객체를 만들어서 MoveNext()가 false일 때까지 불러가며 Current 값을 접근하면 되는거다.<br />
거엽 선배님께서 이야기하셨던 것 중 python의 range, xrange의 차이를 보는 것도 도움이 될 듯. (lazy evaluation)<br />
<br />
개인적으로는 user mode context switching 지지자인데 그게 구현되었다면 c#에서도 async/await같은 trick을 쓰지 않고 진정 막장 구현이 가능했을 것이라고 본다...만 .net에서는 지원할 생각이 없는 듯.<br />
<br />
#<br />
io<br />
user -&gt; kernel (kernel + device driver) -&gt; physical -&gt; kernel -&gt; user로 이어지는 장대한 여행<br />
<a href="http://board.poolc.org/tips/33">http://board.poolc.org/tips/33</a><br />
<br />
약간 거리가 있지만<br />
<a href="/a/비동기_IO_함수.html">비동기 IO 함수</a><br />
<a href="/a/IO_와_메모리_복사.html">IO와 메모리 복사</a><br />
<br />
어쨌든 io는 request 과정과 completion을 처리하는 과정 두 개로 나누어 생각해볼 수 있다.<br />
하나의 io 함수가 두 개를 모두 처리한다면 (보통은) blocking function이 될 것이고, 이 둘을 나누어서 처리한다면 non-blocing function이 될 것이다.<br />
<pre class="brush: cpp; html-script: true">ret sync_io(...) {<br />
    request(...);<br />
    wait_for_completion(infinite);<br />
    return result_from_completion();<br />
}</pre><br />
<pre class="brush: cpp; html-script: true">void async_io_req_callback(...) {<br />
    register_callback();<br />
    request(...);<br />
}<br />
ret async_io_callback(...) {<br />
    return result_from_completion();<br />
}</pre><br />
<pre class="brush: cpp; html-script: true">void async_io_req_completion_queue(...) {<br />
    request(...);<br />
}<br />
void worker_loop() {<br />
    while (true) {<br />
        var completion = dequeue_completion_from_queue();<br />
        // process completion<br />
    }<br />
}</pre><br />
async io 방식은 callback을 등록해서 완료 시 callback이 호출되는 방식과,<br />
아니면 io가 완료된 시점에 completion이 어떤 queue에 들어가면, 그 queue로부터 하나씩 직접 꺼내서 처리하는 방법이 있다.<br />
callback에 의한 io는 해당 callback이 언제 불러줄지 모른다. 때문에 callback이 불렸을 때 공유 자원을 보호해주는 방법도 좀 까다롭고 코드를 읽기도 쉽지 않다. 하지만 library 제작자 입장에서는 scheduling이 편하다는 장점이 있다.<br />
<br />
completion queue를 사용하는 방법(iocp)은 직접 thread-loop를 작성하여 명시적으로 completion을 처리할 수 있다는 점에서 callback보다는 실행 흐름 제어가 조금 편하다(?)는 장점이 있다고 할 수 있다. 그렇지만 코드를 읽는 측면에서는 callback에 비해서 request와 completion의 거리가 더 멀리 떨어지기 때문에 영 좋지 않을 수도 있다.<br />
<br />
#<br />
async io를 논할 때 reactor와 proactor 개념이 나온다.<br />
간단히 요약하면 reactor는 io의 장치가 준비(ready)된 상태를 감지하여 알려주는 것이고, proactor는 io 요청을 받아서 처리해주고 그 결과(completion)를 비동기로 알려준다는 것이다.<br />
대표적으로 epoll()를 써서 reactor를 구현하거나, iocp가 proactor로 구현되어있다고 생각해보면 되겠다.<br />
<br />
#<br />
asio는 boost library로 async io를 cross-platform으로 사용할 수 있게 해주는 좋은 library이다.<br />
크고 아름다운 ace framework과 비교되어 쓰기 좋다는 평을 받는 듯(?)<br />
<br />
windows에서는 iocp를 쓰고, linux에서는 epoll을 쓰는 것으로 알고 있다.<br />
asio는 proactor pattern으로 구현된 것인데, windows에서는 iocp를 쓰니까 그냥 wrapping만 하면 되고, linux에서는 epoll()을 잘 감싸서 proactor pattern을 user mode에서 구현한 것으로 알고 있다.<br />
요약하면 비동기를 요청하고, completion을 callback으로 받아서 처리한다는 것.<br />
<br />
asio 코딩을 통해 async request/completion의 개념을 이해하면 좋을 것 같아 넣어봤다.<br />
자세한 내용은 asio document이 워낙 잘 되어 있으니 그 쪽을 보면 좋다.<br />
<a href="http://www.boost.org/doc/libs/1_54_0/doc/html/boost_asio.html">http://www.boost.org/doc/libs/1_54_0/doc/html/boost_asio.html</a><br />
<br />
#<br />
iocp <stroke>windows의 자랑(?)</stroke><br />
request와 completion을 분리한 비동기 io 함수와 분리된 두 문맥을 연결해주기 위해 준비되는 overlapped 구조체는 iocp 이전부터 존재했던 windows api이다. (apc 포함)<br />
다만 callback이 불리는 시점도 애매하고 흐름이 눈에 잘 띄지 않으니 completion queue를 api로 노출시켜 접근할 수 있게 만들어준 것.<br />
요약하면,<br />
<pre class="brush: cpp; html-script: true">1) [user] completion port를 만든다.<br />
2) [user] completion port에 io device handle을 (socket 등) 연결(mapping)한다.<br />
3) [user] 해당 handle에 대해 비동기 io 요청을 한다.<br />
4) [user] thread를 만들어서 completion port에 대기시킨다. (GetQueuedCompletionStatus)<br />
5) [kernel] 해당 io 요청이 완료되면 completion port에 completion을 넣어준다.<br />
6) [user] completion port에 대기 중인 thread 중 하나가 깨어나서 해당 completion을 처리한다.</pre><br />
수행 흐름을 명시적으로 관리할 수 있다는 점,<br />
그리고 completion port에 대기 중인 thread를 kernel이 잘 관리하여 적절한 녀석(대충 FILO 방식)을 깨워서 작업을 시킨다는 점이 iocp의 장점이라 하겠다.<br />
<br />
뭐, kernel이 io 작업 다 해주고 user는 completion만 처리하면 되니 다른 일에 집중할 수 있어 더 좋은건 당연한 소리<br />
<br />
#<br />
iocp를 만들고 열심히 profiling을 해보니 3가지 문제가 있댄다.<br />
<pre class="brush: cpp; html-script: true">1) async io 요청할 때 전달되는 memory를 non-paged-pool에 넣기 위해 lock거는 비용<br />
2) GetQueuedCompletionStatus() 함수 등의 api를 부를 때 kernel mode switching 비용<br />
3) request/completion 마다 device handle에 mapping된 completion port handle을 찾는 비용(handle table lookup)</pre><br />
1번의 경우는 zero-byte receive 기법으로 대충 우회가 된다. locked page가 뭔 소리인지는 대충 다음 링크에서 보자.<br />
<a href="/a/IO_와_메모리_복사.html">IO와 메모리 복사</a><br />
<br />
rio는 각 문제를 다음과 같이 해결했다.<br />
1) 프로그램 시작 시 미리 buffer를 만들고 lock을 잡아놓고 쓰자. 그러면 그 이후 요청할 때에는 이미 lock된 memory를 쓰니까 매 요청마다 lock을 걸 필요가 없으니 비용문제 해결<br />
<br />
2) request/completion queue를 user mode에 노출시켜 user mode에 존재하는 queue만 보고도 작업이 될 수 있도록 한다. 그런데 user mode로 노출된 queue는 thread-safe하게 보호해주지 않으니 알아서 잘 보호해서 써라.<br />
(그런데 이 queue들이 어떻게 kernel 자료구조와 mapping되는지는 아직 잘 모르겠음-_-)<br />
<br />
3) iocp는 device handle로 요청하고 completion port로 completion이 와야하기 때문에 handle lookup이 일어나는데, rio에서는 이걸 미리 queue를 각자 다 따로 만들어서 연결해두기 때문에 handle lookup 과정이 없다는 것<br />
<br />
<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms740642(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/ms740642(v=vs.85).aspx</a><br />
<a href="http://channel9.msdn.com/Events/Build/BUILD2011/SAC-593T">http://channel9.msdn.com/Events/Build/BUILD2011/SAC-593T</a><br />
<br />
사실 성능에 좀 의문이 있기는 했는데, 이걸로 실험해본 사람이 iocp보다 30~40% 성능 향상을 경험했다고 한다. 좀 미묘한 설계이기는 했는데 나중에 기회가 되면 글 쓰겠음.<br />
<br />
#<br />
병렬성과 비동기는 연관성이 있는 내용이라고 생각했기 때문에 위와 같은 keyword를 던저보았다.<br />
그나마 친숙한 비동기 함수는 비동기 io라서 주제로 잡은 것도 있지만, 다음 주제가 distributed system이니 적어도 network programming은 알아야 한다고 생각해서 밀어붙였던 것도 있다.<br />

				</div>
                <hr>

                <!-- the comments -->
				<div id="disqus_thread"></div>
				<script type="text/javascript">
					/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
					var disqus_shortname = 'lacti'; // required: replace example with your forum shortname

					/* * * DON'T EDIT BELOW THIS LINE * * */
					(function() {
						var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
						dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
						(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
					})();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
				<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

            </div>

            <div class="col-lg-4">

                <div class="well">
					<h4>Related</h4>
					<ul>
						<li><a href="/a/여의도_스터디_정리__1.html">여의도 스터디 정리 #1</a> <span class="date">8. 3.</span></li>
						<li><a href="/a/여의도_스터디_정리__2.html">여의도 스터디 정리 #2</a> <span class="date">8. 10.</span></li>
						<li><a href="/a/여의도_스터디_정리__4.html">여의도 스터디 정리 #4</a> <span class="date">8. 26.</span></li>
					</ul>
                </div>
                <!-- /well -->
                <div class="well">
					<h4>Recents <a href="/" class="show-all">(all)</a></h4>
					<ul>

						<li><a href="/a/패킷_enum에_따른_packet_콜백_함수_자동생성.html">패킷 enum에 따른 packet 콜백 함수 자동생성</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴__2.html">비동기 프로그래밍 패턴 #2</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴.html">비동기 프로그래밍 패턴</a> <span class="date">10. 9.</span></li>
						<li><a href="/a/websocket,_webRTC.html">websocket, webRTC</a> <span class="date">9. 7.</span></li>
						<li><a href="/a/여의도_스터디_정리__4.html">여의도 스터디 정리 #4</a> <span class="date">8. 26.</span></li>
						<li><a href="/a/여의도_스터디_정리__3.html">여의도 스터디 정리 #3</a> <span class="date">8. 18.</span></li>
						<li><a href="/a/여의도_스터디_과제_풀이__2.html">여의도 스터디 과제 풀이 #2</a> <span class="date">8. 12.</span></li>
					</ul>
                </div>
                <!-- /well -->
				<gcse:search></gcse:search>
            </div>
        </div>

        <hr>

        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; lacti 2014</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- JavaScript -->
    <script src="../js/jquery-1.10.2.js"></script>
    <script src="../js/bootstrap.js"></script>

	<script type='text/javascript'>
		SyntaxHighlighter.all();
	</script>

	<script>
	  (function() {
		var cx = '001870890642618183212:k8iqprsstre';
		var gcse = document.createElement('script');
		gcse.type = 'text/javascript';
		gcse.async = true;
		gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
			'//www.google.com/cse/cse.js?cx=' + cx;
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(gcse, s);
	  })();
	</script>
</body>

</html>
