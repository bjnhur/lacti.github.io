<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="blog">
    <meta name="author" content="lacti">

    <title>여의도 스터디 과제 풀이 #1</title>

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/blog-post.css" rel="stylesheet">

	<!-- Syntax highlighter -->
    <link href="../css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
    <link href="../css/shCore.css" rel="stylesheet" type="text/css" />
</head>

<body>

    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">#</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="#about">About</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <div class="container">

        <div class="row">
            <div class="col-lg-8">

                <h2>여의도 스터디 과제 풀이 #1</h2>
                <p>
                    <span class="glyphicon glyphicon-time"></span> Posted on August 04, 2013 at 1:53 AM</p>
                <hr>
                <div class="content">
#<br />
먼저 간단한 counter example을 만들어보자.<br />
문제를 확인하기 위해서 다음과 같은 코드를 작성해본다.<br />
<pre class="brush: cpp">const int thread_count = 128;
const int loop_count = 65536;

volatile int counter;

void add_entry()
{
    for (int loop_index = 0; loop_index &lt; loop_count; ++loop_index)
        ++counter;
}

int _tmain(int argc, _TCHAR* argv[])
{
    std::vector&lt;std::thread&gt; threads;
    for (int thread_index = 0; thread_index &lt; thread_count; ++thread_index)
    {
        threads.push_back(std::thread(add_entry));
    }

    for (auto& each : threads)
        each.join();

    std::cout &lt;&lt; "expect: " &lt;&lt; thread_count * loop_count &lt;&lt; std::endl;
    std::cout &lt;&lt; "actual: " &lt;&lt; counter &lt;&lt; std::endl;
    return 0;
}</pre>
c++ code 한 줄이 원자적(atomic)으로 실행된다는 보장은 없다. assembly의 한 줄도 원자적으로 실행된다는 보장은 없다(smp, micro-operation)<br />
위 코드를 release로 빌드해보면 ++counter 부분에 대한 코드가 assembly로 한 줄이 나오는데, 어쨌든 expect와 actual 값이 다르게 나온다는 것은 해당 연산이 원자적으로 수행되지 않는다는 것이다.<br />
<br />
재밌는 것은 volatile keyword를 제거한 후 release로 build하면 제법 문제없는 결과가 나오는 것처럼 보인다는 것이다.<br />
그 이유를 생성된 assembly code를 통해 확인하면 알 수 있는데, for (loop_counter) ++counter 부분이 counter += loop_counter 코드로 최적화되어 버리기 때문이다.<br />
counter += loop_counter 명령은 원자적이지 않지만, 다음 thread가 생성되어 간섭하기 전에 완료될 수 있을만큼 명령이 단순하므로 thread간 간섭이 없어 문제가 발생하지 않는 것처럼 보이는 것이다.<br />
(직접 위 코드를 release로 빌드하여 assembly를 확인해보면 더욱 명확하다)<br />
<br />
위 문제를 해결하기 위한 적어도 3가지 방법을 하나씩 알아보자.<br />
<br />
#<br />
가장 손쉬운 해결법은 lock을 사용하는 것이다.<br />
<pre class="brush: cpp">std::mutex m;

void add_entry()
{
    for (int loop_index = 0; loop_index &lt; loop_count; ++loop_index)
    {
        std::unique_lock&lt;std::mutex&gt; lock(m);
        ++counter;
    }
}</pre>
간단하게 전역 변수로 mutex를 추가하고, ++counter 수행 전후의 단일 thread 진입을 보장해주기 위해 lock을 걸었다.<br />
수행시간이 굉장히(!) 오래 걸리고 cpu도 엄청 소모하지만 한참 기다리면 어쨌든 actual과 expect가 동일하게 나오는 것을 볼 수 있다.<br />
<br />
#<br />
두 번째 해결책은 atomic_int를 사용하는 것이다. (<a href="/a/volatile_과_interlocked_operation.html">volatile과 interlocked operation</a>)<br />
<pre class="brush: cpp">std::atomic_int counter;

void add_entry()
{
    for (int loop_index = 0; loop_index &lt; loop_count; ++loop_index)
        ++counter;
}</pre>
결과도 굉장히 빠르게 나오고, 제대로 actual과 expect가 같게 나온다.<br />
atomic_int::operator++()은 내부에서 atomic_fetch_add() 함수를 부르게 된다. 여기서 memory_order를 지정할 수 있는데  windows api는 (arm을 사용하지 않을 경우) memory order가 뭐인지와 상관없이 _InterlockedExchangeAdd() [Intrinsic] 함수를 부른다.<br />
(물론 기본 memory_order 값은 memory_order_seq_cst이다)<br />
<br />
#<br />
세 번째 해결책으로 넘어가기 전에 두 번째 해결책에서 배운 atomic을 사용하여 첫 번째 해결책의 성능을 개선해보자.<br />
lock을 직접 만들어서 성능을 개선하는 것이다.(<http://en.cppreference.com/w/cpp/atomic/atomic_flag">http://en.cppreference.com/w/cpp/atomic/atomic_flag</a>)<br />
<pre class="brush: cpp">volatile int counter;
std::atomic_flag lock = ATOMIC_FLAG_INIT;

void add_entry()
{
    for (int loop_index = 0; loop_index &lt; loop_count; ++loop_index)
    {
        while (lock.test_and_set(std::memory_order_acquire))
             ; // spin
        ++counter;
        lock.clear(std::memory_order_release);
    }
}</pre>
동기화를 위해 atomic_flag를 사용한다. lock이라는 flag를 획득하지 못할 경우 spin-wait을 수행하고, 얻으면 ++counter를 한다. 작업이 끝나면 lock flag를 clear해서 다른 thread가 진입하게 하는 것이다.<br />
이전에 lock을 쓸 때에 비해서 성능이 훨씬 좋아졌다. (그래도 atomic_int를 사용하는 것에 비하면 많이 느리다.)<br />
<br />
#<br />
세 번째 방법은 actor 기반의 message passing을 사용하는 것이다.<br />
<pre class="brush: cpp">enum message_t {
    msg_none,
    msg_add
};

class actor_t {
public:
    actor_t() 
        : exited(false) {
        worker = std::thread(std::bind(&actor_t::dispatch, this));
    }
    ~actor_t() {
        exited = true;
        worker.join();
    }
    void dispatch() {
        message_t msg = msg_none;
        while (message_queue.try_pop(msg) || !exited) {
            switch (msg) {
            case msg_none:
                std::this_thread::sleep_for(std::chrono::seconds(0));
                break;
            case msg_add:
                ++value;
                break;
            }
            msg = msg_none;
        }
    }
    void request(message_t msg) {
        message_queue.push(msg);
    }
public:
    int value;
private:
    bool exited;
    std::thread worker;
    concurrency::concurrent_queue&lt;message_t&gt; message_queue;
};

actor_t counter;

void add_entry()
{
    for (int loop_index = 0; loop_index &lt; loop_count; ++loop_index)
        counter.request(msg_add);
}</pre>
actor_t는 dispatch() 함수에서 message_queue에 쌓인 message를 자체적인 worker thread를 사용하여 비동기로 처리되도록 구성된 class이다. (대충 구현해서 성능은 안 좋다)<br />
concurrent_queue가 비어있을 때(empty)에는 try_pop()이 바로 실패하므로, worker thread가 message를 과도하게 busy-waiting하지 않도록 대충 sleep(0)을 넣어주었다.<br />
<br />
어쨌든 각 test thread들은 add_entry()에서 counter라는 actor에게 msg_add를 전달하고, msg_add는 counter의 message_queue에 쌓이게 된다.<br />
그러면 counter내의 worker thread가 message_queue에 쌓인 msg_add를 하나씩 처리하기 때문에 counter::value 변수는 하나의 thread만 (write를 위해) 접근하게 되고, 이 변수는 간섭없이 증가할 수 있는 것이다.<br />
<br />
다만 위 코드를 수행할 경우 프로그램의 수행 시간이 굉장히 오래 걸린다. (std::mutex/lock을 사용했을 때 보다도 몇 배는 더 오래 걸린다.) 그 이유는 actor를 대충 구현해서 그런 것도 있지만 concurrent_queue가 너무 느린 것도 한 몫 하는 것 같다-_-<br />
<br />
#<br />
다양한 방법으로 counter example의 공유 자원 정합성 문제를 해결해보았다.<br />
게임 등의 다른 로직에서도 위에서 언급한 방법 혹은 다른 방법을 통해 동시성 보장을 위해 상황에 맞는 적절한 방법을 찾아 구현하면 되겠다.<br />
(물론 난 별로 자신 없다-_-)<br />

				</div>
                <hr>

                <!-- the comments -->
				<div id="disqus_container">
					<div id="disqus_thread"></div>
					<script type="text/javascript">
						var disqus_shortname = 'lacti';
						(function() {
							var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
							dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
							(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
						})();
					</script>
					<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
					<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
				</div>
            </div>

            <div class="col-lg-4 sides">

                <div class="well">
					<h4>Related</h4>
					<ul>
						<li>여의도 스터디 과제 풀이 #1 <span class="date">8. 4.</span></li>
						<li><a href="/a/여의도_스터디_과제_풀이__2.html">여의도 스터디 과제 풀이 #2</a> <span class="date">8. 12.</span></li>
					</ul>
                </div>
                <!-- /well -->
                <div class="well">
					<h4>Recents <a href="/" class="show-all">(all)</a></h4>
					<ul>

						<li><a href="/a/패킷_enum에_따른_packet_콜백_함수_자동생성.html">패킷 enum에 따른 packet 콜백 함수 자동생성</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴__2.html">비동기 프로그래밍 패턴 #2</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴.html">비동기 프로그래밍 패턴</a> <span class="date">10. 9.</span></li>
						<li><a href="/a/websocket,_webRTC.html">websocket, webRTC</a> <span class="date">9. 7.</span></li>
						<li><a href="/a/여의도_스터디_정리__4.html">여의도 스터디 정리 #4</a> <span class="date">8. 26.</span></li>
						<li><a href="/a/여의도_스터디_정리__3.html">여의도 스터디 정리 #3</a> <span class="date">8. 18.</span></li>
						<li><a href="/a/여의도_스터디_과제_풀이__2.html">여의도 스터디 과제 풀이 #2</a> <span class="date">8. 12.</span></li>
					</ul>
                </div>
                <!-- /well -->
				<gcse:search></gcse:search>
            </div>
        </div>

        <footer>
			<hr>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; lacti 2014</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- JavaScript -->
    <script src="../js/jquery-1.10.2.js"></script>
    <script src="../js/bootstrap.js"></script>

	<script>
	  (function() {
		var cx = '001870890642618183212:k8iqprsstre';
		var gcse = document.createElement('script');
		gcse.type = 'text/javascript';
		gcse.async = true;
		gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
			'//www.google.com/cse/cse.js?cx=' + cx;
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(gcse, s);
	  })();
	</script>
	
    <script src="../js/shCore.js" type="text/javascript"></script>
    <script src="../js/shAutoloader.js" type="text/javascript"></script>
	<script>
		if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
			// do nothing
		} else {
			SyntaxHighlighter.autoloader(
			  'bash shell             ../js/shBrushBash.js',
			  'cpp c                  ../js/shBrushCpp.js',
			  'c# c-sharp csharp      ../js/shBrushCSharp.js',
			  'css                    ../js/shBrushCss.js',
			  'java                   ../js/shBrushJava.js',
			  'js jscript javascript  ../js/shBrushJScript.js',
			  'php                    ../js/shBrushPhp.js',
			  'text plain             ../js/shBrushPlain.js',
			  'py python              ../js/shBrushPython.js',
			  'ruby rails ror rb      ../js/shBrushRuby.js',
			  'sql                    ../js/shBrushSql.js',
			  'xml xhtml xslt html    ../js/shBrushXml.js'
			);
			SyntaxHighlighter.defaults['toolbar'] = false;
			SyntaxHighlighter.all();
		}
	</script>
</body>

</html>
