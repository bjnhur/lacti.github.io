<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="blog">
    <meta name="author" content="lacti">

    <title>c++에서 reflection 사용하기 #3</title>

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/blog-post.css" rel="stylesheet">

	<!-- Syntax highlighter -->
    <link href="../css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
    <link href="../css/shCore.css" rel="stylesheet" type="text/css" />
</head>

<body>

    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">#</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="#about">About</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <div class="container">

        <div class="row">
            <div class="col-lg-8">

                <h2>c++에서 reflection 사용하기 #3</h2>
                <p>
                    <span class="glyphicon glyphicon-time"></span> Posted on June 09, 2012 at 6:34 PM</p>
                <hr>
                <div class="content">
#<br />
지난 #2에서는 class_t, field_t 자체가 가상 함수를 갖고, class_impl_t와 field_impl_t가 이 class를 상속 받아서 구현하는 방식을 사용하였다. 사실 굳이 이 impl_t class 들은 노출될 필요가 없으므로 이를 감추도록 해보자.<br />
<br />
그리고 다 완성된 type을 register함에 있어, 따로 register_class, register_field 함수를 직접 불러서 등록을 하였는데,<br />
이것을 <strong>유병후 접근법</strong>을 사용하여 개선해보도록 하자.<br />
<br />
#<br />
<strong>C++ Template Metaprogramming</strong>의 형식 삭제(type erasure) 부분을 읽다보니,<br />
굳이 impl_t class를 class_t, field_t 외부로 노출할 필요가 없다는 것을 깨달았다.<br />
<br />
(물론 위 책에서 언급하는 예제는 복사 및 대입 가능한 대상이기 때문에 복사/대입/소멸 등도 고려되어 있지만, 본 글에서는 단지 impl_t를 숨기기 위한 용도 정도로만 사용한다.)<br />
<br />
type erasure에 대한 개념을 간단히 적어보면,<br />
reflection을 만든다는 것은 결국 runtime까지 type 정보를 유지한다는 것이다.<br />
type 정보를 코드 하나하나에 다 열거하는 것은 쓸데없는 노동력을 요구하므로 적절히 template 을 써서 type 정보를 capture한다.<br />
<br />
문제는 이렇게 type capture를 한 template class는 일반 type으로 지칭할 수 없다는 귀찮은 점이 있다.<br />
예를 들어서,<br />
<pre class="brush: cpp">template &lt;class _Ty&gt;
class class_t {};</pre>
위와 같은 class_t에 대해, class_t<int> 와 같은 type 정보를 넣어 template class를 구체화했다면,<br />
이 class는 class_t가 아니고 class_t<int>이다. 좀 더 엄밀히 말하면 구체화되지 않은 class_t 라는 class는 없는 것이다.<br />
<br />
때문에 지난 번에는 class_t 와 그것을 상속받는 class_impl_t를 만들고, type 정보를 class_impl_t에만 국한시켜 실제 사용하는 class_t에서는 따로 type 정보 없이 사용할 수 있는 것이다.<br />
<br />
하지만 외부 register 함수에서 class_impl_t, field_impl_t 객체를 직접 생성해서 class_t, field_t에 넣어주는 영 좋지 못한 구조를 보였다. 이를 함수 template을 사용하여 보다 나은 방법으로 개선해보자.<br />
<br />
#<br />
변경된 class_t는 다음과 같다. (class_impl_t는 삭제되었다, 그리고 지난 번과 중복되는 내용은 삭제한다.)<br />
<pre class="brush: cpp">class class_t {
public:
    template &lt;typename _Ty&gt;
    class_t(const typeinfo&lt;_Ty&gt;&, std::string name)
        : inf(new impl_t&lt;_Ty&gt;), class_name(name) {}

    template &lt;typename _Class&gt;
    _Class* new_instance() const {
        return reinterpret_cast&lt;_Class*&gt;(inf-&gt;new_instance());
    }
private:
    struct interface_t {
        virtual void* new_instance() const = 0;
    };
    template &lt;typename _Ty&gt;
    struct impl_t : public interface_t {
        virtual void* new_instance() const { return new _Ty; }
    };
private:
    std::shared_ptr&lt;interface_t&gt; inf;
};</pre>
지난 번과 동일한 부분을 과감히 생략하고 변경된 부분만 모아보면 위와 같다.<br />
class_t 내부에 interface_t와 impl_t가 들어갔다.<br />
impl_t는 template을 사용하여 실 type 정보를 capture할 class이고,<br />
interface_t는 impl_t를 일반적으로 접근하기 위한 interface class이다.<br />
<br />
class_t의 생성자가 type 정보를 직접 받기 위해 template 함수로 작성되었다.<br />
재밌는 점은, 함수 template 생성자에 type 정보를 넘기기 위해 < >으로 명시해주는 것은 쓸 수가 없어서,<br />
이를 적당히 회피하기 위해 type 정보를 컴파일러에게 알려주기 위해 class 하나를 추가한다.<br />
<pre class="brush: cpp">template &lt;typename _Ty&gt;
class typeinfo {};</pre>
<br />
그래서 class_t 생성자는 typeinfo<_Ty> 객체를 인자로 받는 것이고, <br />
이 인자를 통해 어떤 _Ty을 넘기려 하는 것인지 type 추론이 가능해진다.<br />
<br />
그러면 해당 type으로 생성자가 구체화가 되고,<br />
그 생성자에서는 _Ty 정보를 사용하여 impl_t 객체를 만들고, 이 객체를 interface_t 변수에 넣어두는 것이다.<br />
그러면 기존 class_t의 virtual 함수를 non-virtual 함수로 만들고 수행에 대해서는 내부 interface_t 객체를 통해 적절히 delegate해주면 된다.<br />
<br />
#<br />
field_t 역시 위와 동일한 방법으로 개선하였다.<br />
<pre class="brush: cpp">class field_t {
public:
    template &lt;typename _ObjTy, typename _FieldTy&gt;
    field_t(_FieldTy (_ObjTy::*Field), std::string name)
        : inf(new impl_t&lt;_ObjTy, _FieldTy&gt;(field)), field_name(name) {}
private:
    struct interface_t {
        virtual void* ptr(void* obj_addr) const = 0;
        virtual const std::type_info& type() const = 0;
    };
    template &lt;typename _ObjTy, typename _FieldTy&gt;
    struct impl_t : public interface_t {
        impl_t(_FieldTy (_ObjTy::*Field)) : field(Field) {}
        virtual const std::type_info& type() const { return typeid(_FieldTy); }
        virtual void* ptr(void* obj_addr) const;

        _FieldTy (_ObjTy::*field);
    };
private:
    std::shared_ptr&lt;interface_t&gt; inf;
};</pre>
생성자를 template 함수로 만드는 방법은 class_t와 똑같은데, 아까 만든 typeinfo를 사용하여 type정보를 넘기지는 않는다.<br />
기존의 field_impl_t에서 실제 field까지 template 인자로 받았던 것에 반해, 새로운 구조에서는 data member pointer를 생성 인자로 받기 때문에 _FieldTy (_ObjTy::*Field) 이 인자를 통해서 충분한 type 유추가 가능하기 때문이다.<br />
(따라서 impl_t도 data member pointer를 인자로 갖도록 수정되었다.)<br />
<br />
그 이외에 impl_t 객체를 만들어서 interface_t로 지칭하는 것이나, field_t의 작업 함수들이 수행을 interface_t 객체로 위임하는 것은 위 class_t에서 언급했던 내용과 동일하다.<br />
<br />
#<br />
이제 reflection 정보를 register하는 코드를 개선할 것이다.<br />
기존에는 외부로 노출된 template 함수를 통해 직접 type 및 이름 정보를 입력하여 하나씩 정보를 등록하였다.<br />
<br />
하지만 각 field를 정의할 때마다 어떤 class에 대한 field인지 매번 써주는 것은 비효율적이므로, 이를 개선하기 위해 다음과 같이 register를 도와주면서 어떤 class에 대한 register인지 type 정보를 갖고 있는 class를 설계해보자.<br />
<pre class="brush: cpp">template &lt;typename _ObjTy&gt;
struct reflection_register_helper_t {
    typedef _ObjTy target_type;

    static void register_class(std::string class_name);
    template &lt;typename _FieldTy&gt;
    static void register_field(_FieldTy (_ObjTy::*Field), std::string field_name);
};

template &lt;typename _ObjTy&gt;
inline void reflection_register_helper_t&lt;_ObjTy&gt;::register_class(std::string class_name)
{
    reflection_base::instance().add_class_name(&typeid(_ObjTy), class_name);
    reflection_base::instance().add_class(class_name, 
        new class_t(typeinfo&lt;_ObjTy&gt;(), class_name));
}

template &lt;typename _ObjTy&gt;
template &lt;typename _FieldTy&gt;
inline void reflection_register_helper_t&lt;_ObjTy&gt;::register_field(
    _FieldTy (_ObjTy::*Field), std::string field_name)
{
    const char* class_name = reflection_base::instance()
	    .class_name_from_typeinfo(&typeid(_ObjTy));
    assert(class_name);

    reflection_base::instance().add_field(class_name, field_name,
        new field_t(Field, field_name));
}</pre>
<br />
reflection_register_helper_t class는 template으로 type 정보를 받고 이를 유지한다.<br />
따라서 register_class() 함수나 register_field() 함수는 따로 어떤 class에 대한 정보인지 type 정보를 받을 필요가 없다.<br />
<br />
이제 매크로를 통해 다음과 같이 대신 등록해주는 코드를 만들어볼 수 있다.<br />
<pre class="brush: cpp">#define REFLECTION_REGISTER_BEGIN(class_name)  \
    static struct _register_##class_name :
            public reflection::reflection_register_helper_t&lt;class_name&gt; { \
       _register_##class_name() \
        { \
            register_class(#class_name);

#define REFLECTION_REGISTER_FIELD(type, field_name) \
            register_field&lt;type&gt;(&target_type::field_name, #field_name);

#define REFLECTION_REGISTER_END()  \
        } \
    } __AUTO_NAME;</pre>
(__AUTO_NAME은 __COUNTER__를 사용하여 겹치지 않는 아무 이름이나 만들어주는 매크로이다. <a href="/a/lambda_와_RAII__2.html">lambda 와 RAII #2</a>)<br />
<br />
REFLECTION_REGISTER_BEGIN, FIELD, END 매크로를 사용하면 등록하고자 하는 class의 정보를 template argument로 갖는 reflection_register_helper_t에 대한 상속 class를 만든다.<br />
그리고 생성자에서 class, field 정보를 등록하는 코드를 차례대로 만들어둔 뒤, END 매크로에서 이 register_class에 대한 변수를 하나 만들게 된다.<br />
<br />
만약 이 변수가 전역 변수로 선언된다면 프로그램이 실행될 때 해당 객체가 초기화되면서 생성자의 코드가 실행될 것이고,<br />
그 때 해당 type에 대한 reflection 정보가 등록될 것이다.<br />
<br />
<pre class="brush: cpp">REFLECTION_REGISTER_BEGIN(user_t)
	REFLECTION_REGISTER_FIELD(int, index)
	REFLECTION_REGISTER_FIELD(std::string, name)
REFLECTION_REGISTER_END()</pre>
(reflection_register_helper_t class가 user_t에 대한 type 정보를 target_type이라고 지칭할 수 있게 해주어서, FIELD를 등록할 때 다시 user_t를 언급할 필요가 없어졌다!)<br />
<br />
#<br />
이제 libsora님이 제시한 <strong>#include x 2</strong> 방법을 정의한 구조체에 대한 type 정보를 등록하는 것을 자동화해볼 것이다.<br />
(<a href="http://board.poolc.org/generation07/2055">http://board.poolc.org/generation07/2055</a>)<br />
<br />
이 방법의 핵심은 구조체 선언을 매크로로 하고,<br />
선언된 header 파일을 여러 번 incldue하고, 그 때마다 선언 매크로를 다른 것으로 치환(undef/define)하여 사용하는 것이다.<br />
<br />
먼저 선언을 위한 매크로를 정의해보면 다음과 같다.<br />
<pre class="brush: cpp">#ifndef __DECLARE_TYPE_MACRO_DEFINED__
#define __DECLARE_TYPE_MACRO_DEFINED__
#define DECLARE_BEGIN(class_name) \
    struct class_name; \
    typedef std::shared_ptr&lt;class_name&gt; class_name##_ref; \
    struct class_name : public object_t {

#define DECLARE_FIELD(type, field_name) \
        type field_name;

#define DECLARE_END()   \
    };
#endif

#define STRUCT_BEGIN(class_name)        DECLARE_BEGIN(class_name)
#define STRUCT_FIELD(type, field_name)  DECLARE_FIELD(type, field_name)
#define STRUCT_END()                    DECLARE_END()</pre>
(본 글에서는 생략했지만 DECLARE로 정의된 모든 class는 object_t를 상속받고, object_t는 reflection_class_t를 상속받기 때문에 reflection 정보를 가질 수 있다.)<br />
<br />
STRUCT_BEGIN, FIELD, END 매크로는 선언(declare) 단계에서는 DECLARE_BEGIN, FIELD, END를 사용하도록 작성이 되어있다.<br />
이제 다음과 같이 user_t를 정의하면 (user.h)<br />
<pre class="brush: cpp">STRUCT_BEGIN(user_t)
    STRUCT_FIELD(int, index)
    STRUCT_FIELD(std::string, name)
STRUCT_END()</pre>
위 매크로에 의해 다음과 같이 번역될 것이다. (STRUCT -> DECLARE)<br />
<pre class="brush: cpp">struct user_t {
    int index;
    std::string name;
};</pre>
<br />
이제, STRUCT_BEGIN, FIELD, END를 reflection을 등록하기 위한 매크로로 치환한다. (type_register_macro.h)<br />
<pre class="brush: cpp">#ifdef STRUCT_BEGIN
#undef STRUCT_BEGIN
#endif

#ifdef STRUCT_END
#undef STRUCT_END
#endif

#ifdef STRUCT_FIELD
#undef STRUCT_FIELD
#endif

#define STRUCT_BEGIN(class_name)        REFLECTION_REGISTER_BEGIN(class_name)
#define STRUCT_FIELD(type, field_name)  REFLECTION_REGISTER_FIELD(type, field_name)
#define STRUCT_END()                    REFLECTION_REGISTER_END()</pre>
<br />
이제 다시 user.h 파일을 include하면, 이 때의 코드는 다음과 같이 번역될 것이다. (STRUCT -> REFLECTION_REGISTER)<br />
<pre class="brush: cpp">REFLECTION_REGISTER_BEGIN(user_t)
	REFLECTION_REGISTER_FIELD(int, index)
	REFLECTION_REGISTER_FIELD(std::string, name)
REFLECTION_REGISTER_END()</pre>
<br />
이에 대한 전체적인 코드 구조는 다음과 같다.<br />
<pre class="brush: cpp">#include "object.h"
#include "user.h"

#include "type_register_macro.h"
#include "user.h"

int main(int argc, char* argv[]) {
    const reflection::class_t* clazz = reflection::class_t::from_name("user_t");</pre>
<br />
DECLARE 매크로 정의를 포함한 object.h를 먼저 include하면, 그 뒤에 오는 user.h를 include하는 시점에는 구조체 선언이 이루어진다.<br />
그리고 REFLECTION_REGISTER 매크로로 치환하는 type_register_macro.h를 include한 이후에 오는 user.h에서는 reflection 정보를 자동으로 등록하는 코드가 생성될 것이다.<br />
<br />
#<br />
본 글에서는 class_impl_t, field_impl_t를 숨기는 작업과,<br />
매크로 치환과 #include를 여러 번 하는 방법을 사용하여 type 정보를 자동으로 등록하는 방법에 대해 알아보았다.<br />
<br />
하지만 #include를 여러 번 하는 방법은,<br />
#pragma once나 #ifndef, #define ~ #endif을 통한 중복 include 방지를 사용할 수 없기 때문에,<br />
(혹은 사용한다고 하면 번거롭게 구조체 정의할 때마다 앞 뒤로 매크로 선언을 따로 해주어야 하기 때문에)<br />
include가 복잡하게 꼬이는 구조가 발생하면 여러 번 include 되어 문제가 발생할 수 있다.<br />
<br />
매크로 상태를 사용하여 이를 해결할 수는 있는데,<br />
이에 대해서는 다음 글에 알아보도록 하자.<br />

				</div>
                <hr>

                <!-- the comments -->
				<div id="disqus_thread"></div>
				<script type="text/javascript">
					var disqus_shortname = 'lacti';
					(function() {
						var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
						dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
						(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
					})();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
				<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

            </div>

            <div class="col-lg-4">

                <div class="well">
					<h4>Related</h4>
					<ul>
						<li><a href="/a/c++에서_reflection_사용하기__1.html">c++에서 reflection 사용하기 #1</a> <span class="date">6. 3.</span></li>
						<li><a href="/a/c++에서_reflection_사용하기__2.html">c++에서 reflection 사용하기 #2</a> <span class="date">6. 4.</span></li>
						<li>c++에서 reflection 사용하기 #3 <span class="date">6. 9.</span></li>
						<li><a href="/a/c++에서_reflection_사용하기__4.html">c++에서 reflection 사용하기 #4</a> <span class="date">6. 9.</span></li>
					</ul>
                </div>
                <!-- /well -->
                <div class="well">
					<h4>Recents <a href="/" class="show-all">(all)</a></h4>
					<ul>

						<li><a href="/a/패킷_enum에_따른_packet_콜백_함수_자동생성.html">패킷 enum에 따른 packet 콜백 함수 자동생성</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴__2.html">비동기 프로그래밍 패턴 #2</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴.html">비동기 프로그래밍 패턴</a> <span class="date">10. 9.</span></li>
						<li><a href="/a/websocket,_webRTC.html">websocket, webRTC</a> <span class="date">9. 7.</span></li>
						<li><a href="/a/여의도_스터디_정리__4.html">여의도 스터디 정리 #4</a> <span class="date">8. 26.</span></li>
						<li><a href="/a/여의도_스터디_정리__3.html">여의도 스터디 정리 #3</a> <span class="date">8. 18.</span></li>
						<li><a href="/a/여의도_스터디_과제_풀이__2.html">여의도 스터디 과제 풀이 #2</a> <span class="date">8. 12.</span></li>
					</ul>
                </div>
                <!-- /well -->
				<gcse:search></gcse:search>
            </div>
        </div>

        <hr>

        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; lacti 2014</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- JavaScript -->
    <script src="../js/jquery-1.10.2.js"></script>
    <script src="../js/bootstrap.js"></script>

	<script>
	  (function() {
		var cx = '001870890642618183212:k8iqprsstre';
		var gcse = document.createElement('script');
		gcse.type = 'text/javascript';
		gcse.async = true;
		gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
			'//www.google.com/cse/cse.js?cx=' + cx;
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(gcse, s);
	  })();
	</script>
	
    <script src="../js/shCore.js" type="text/javascript"></script>
    <script src="../js/shAutoloader.js" type="text/javascript"></script>
	<script>
		if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
			// do nothing
		} else {
			SyntaxHighlighter.autoloader(
			  'bash shell             ../js/shBrushBash.js',
			  'cpp c                  ../js/shBrushCpp.js',
			  'c# c-sharp csharp      ../js/shBrushCSharp.js',
			  'css                    ../js/shBrushCss.js',
			  'java                   ../js/shBrushJava.js',
			  'js jscript javascript  ../js/shBrushJScript.js',
			  'php                    ../js/shBrushPhp.js',
			  'text plain             ../js/shBrushPlain.js',
			  'py python              ../js/shBrushPython.js',
			  'ruby rails ror rb      ../js/shBrushRuby.js',
			  'sql                    ../js/shBrushSql.js',
			  'xml xhtml xslt html    ../js/shBrushXml.js'
			);
			SyntaxHighlighter.defaults['toolbar'] = false;
			SyntaxHighlighter.all();
		}
	</script>
</body>

</html>
