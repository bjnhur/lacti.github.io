<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="blog">
    <meta name="author" content="lacti">

    <title>여의도 스터디 과제 풀이 #2</title>
	<link href="http://yui.yahooapis.com/pure/0.3.0/grids-min.css" rel="stylesheet">
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shCore.css' rel='stylesheet' type='text/css' />
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css' rel='stylesheet' type='text/css' />
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushXml.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJScript.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCSharp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCpp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJava.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushBash.js' type='text/javascript'></script>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.css" rel="stylesheet">

    <!-- Add custom CSS here -->
    <link href="../css/blog-post.css" rel="stylesheet">

</head>

<body>

    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">#</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="#about">About</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <div class="container">

        <div class="row">
            <div class="col-lg-8">

                <!-- the actual blog post: title/author/date/content -->
                <h1>여의도 스터디 과제 풀이 #2</h1>
                <p>
                    <span class="glyphicon glyphicon-time"></span> Posted on August 12, 2013 at 12:48 AM</p>
                <hr>
                <div class="content">
#<br />
먹깨비 과제를 풀어보자.<br />
<br />
#<br />
여러 가지 구현법이 있을 것인데, 나는 간단하게<br />
- 바구니는 공유 자원이니 lock으로 보호하고,<br />
- 제빵사와 먹깨비는 actor로 만들어서 매 tick마다 상황 판단 후 작업을 처리하도록 했다.<br />
<br />
따라서 공유 자원을 보호하기 위한 spin_lock과 actor 기반 코드를 만들었고<br />
그 기반으로 바구니, 제빵사, 먹깨비를 만들었다.<br />
<br />
#<br />
먼저 spin_lock을 만들어보자. 이전 글에서 몇 번 설명한적 있으니 대충 보자.<br />
<pre class="brush: cpp; html-script: true">class spin_lock_t {<br />
public:<br />
    spin_lock_t() { _flag.clear(); }<br />
    void acquire() { while (_flag.test_and_set()); }<br />
    void release() { _flag.clear(); }<br />
private:<br />
    std::atomic_flag _flag;<br />
};<br />
<br />
class spin_lock_raii_t {<br />
public:<br />
    explicit spin_lock_raii_t(spin_lock_t& lock)<br />
        : _lock(&lock) {<br />
        _lock->acquire();<br />
    }<br />
    spin_lock_raii_t(spin_lock_raii_t&& other)<br />
        : _lock(other._lock) {<br />
        other._lock = nullptr;<br />
    }<br />
    ~spin_lock_raii_t() {<br />
        if (_lock != nullptr)<br />
            _lock->release();<br />
    }<br />
private:<br />
    spin_lock_raii_t(const spin_lock_raii_t&);<br />
    spin_lock_raii_t& operator = (const spin_lock_raii_t&);<br />
private:<br />
    spin_lock_t* _lock;<br />
};<br />
<br />
template <size_t _lockCount><br />
class spin_lock_support_t {<br />
public:<br />
    spin_lock_raii_t lock(int lock_index = 0) {<br />
        return spin_lock_raii_t(_lock[lock_index]);<br />
    }<br />
private:<br />
    spin_lock_t _lock[_lockCount];<br />
};</pre><br />
spin_lock 자체는 atomic_flag를 사용하여 간단히 만들었다.<br />
spin_lock_raii는 spin_lock을 가지고 생성자/소멸자에서 acquire, release해주는 raii class이다.<br />
그리고 spin_lock_support를 만들어서 lock이 필요한 class에서 이를 상속받아 사용할 수 있도록 코드를 작성하였다. 상황에 따라 lock을 여러 개 사용할 수도 있으므로 lock 개수를 template 인자로 받도록 하였다.<br />
<br />
이를 사용하여 구현한 바구니(basket)은 다음과 같다.<br />
<pre class="brush: cpp; html-script: true">class basket_t : public spin_lock_support_t<1> {<br />
public:<br />
    basket_t() : _bread_count(0) {}<br />
    int count() const { return _bread_count; }<br />
    void add() { ++_bread_count; }<br />
    void sub() { --_bread_count; }<br />
private:<br />
    int _bread_count;<br />
};</pre><br />
lock을 여러 개 사용할 필요가 없으니 spin_lock_support의 template 인자를 1로 지정하여 사용하였다.<br />
이제 다른 actor에서 바구니를 접근할 때에는 다음과 같이 사용할 수 있다.<br />
<pre class="brush: cpp; html-script: true">auto locker = basket.lock();<br />
if (basket.count() >= 20) return;<br />
basket.add();</pre><br />
<br />
#<br />
이제 actor를 만들어보자. ppl의 concurrent_queue는 너무 느려서 actor model의 mpsc queue를 구현하는데 적합하지 않은 것 같다. 따라서 InterlockedSList를 사용하여 간단히 구현해 보았다.<br />
<pre class="brush: cpp; html-script: true">typedef std::function<void()> message_t;<br />
class actor_t {<br />
public:<br />
    actor_t() {<br />
        _job_count = 0;<br />
        InitializeSListHead(&_queue_head);<br />
    }<br />
    void post(message_t message) {<br />
        struct job_entry_t : public SLIST_ENTRY {<br />
            message_t message;<br />
        };<br />
        void* entry_memory = _aligned_malloc(sizeof(message_t), <br />
            MEMORY_ALLOCATION_ALIGNMENT);<br />
        job_entry_t* entry = new (entry_memory) job_entry_t;<br />
        entry->message = message;<br />
<br />
        bool victim = _job_count.fetch_add(1) == 0;<br />
        InterlockedPushEntrySList(&_queue_head, entry);<br />
        if (!victim) return;<br />
        <br />
        int process_count = 0;<br />
        do {<br />
            PSLIST_ENTRY local_head = InterlockedFlushSList(&_queue_head);<br />
            std::vector<message_t> messages;<br />
            messages.reserve(1024);<br />
<br />
            PSLIST_ENTRY it = local_head;<br />
            PSLIST_ENTRY next = nullptr;<br />
            while (it != nullptr) {<br />
                next = it->Next;<br />
<br />
                job_entry_t* each_entry = reinterpret_cast<job_entry_t*>(it);<br />
                messages.push_back(each_entry->message);<br />
<br />
                each_entry->job_entry_t::~job_entry_t();<br />
                _aligned_free(each_entry);<br />
                it = next;<br />
            }<br />
           <br />
            for (auto it = messages.rbegin(); it != messages.rend(); ++it)<br />
                (*it)();<br />
            process_count = static_cast<int>(messages.size());<br />
        }<br />
        while (_job_count.fetch_sub(process_count) != process_count);<br />
    }<br />
    template <typename _SubTy><br />
    void post(void (_SubTy::*method)()) {<br />
        _SubTy* sub_instance = static_cast<_SubTy*>(this);<br />
        post([sub_instance, method] () { (sub_instance->*method)(); });<br />
    }<br />
private:<br />
    SLIST_HEADER _queue_head;<br />
    std::atomic_int _job_count;<br />
};</pre><br />
원리는 간단하다.<br />
수행할 작업을 void() 형태로 받아서 InterlockedSList 기반의 queue에 넣는다.<br />
그리고 처음 queue에 넣는 thread를 victim으로 삼아서 queue 내에 들어있는 작업들을 계속 처리하도록 한다.<br />
이 때 절묘한 타이밍으로 queue에 넣은 작업이 처리될 수 없는 문제를 해결하기 위해 _job_count로 처리 구간을 보장해준다.<br />
<br />
template 인자를 받는 post 함수는 이 actor를 상속받은 하위 class들의 member function pointer를 받아서 this에 대해 post() 함수를 호출해주는 helper function이다. 이 helper function이 있으면 다음과 같이 간결하게 post()를 호출할 수 있다.<br />
<pre class="brush: cpp; html-script: true">eater_t eater;<br />
eater.post(&eater_t::act);</pre><br />
<br />
#<br />
post()가 가능한 actor 기반을 만들었으니, 이를 기반으로 주기적인 작업을 수행하기 위한 interface를 정의해보자.<br />
간단히 다음과 같이 tick_actor_t를 선언하였다.<br />
<pre class="brush: cpp; html-script: true">class tick_actor_t : public actor_t {<br />
public:<br />
    virtual void act() = 0;<br />
};</pre><br />
tick_actor_t class는 주기적으로 act() 함수가 불려져서 뭔가 지속적인 작업을 처리할 수 있도록 하는 의미를 지닌 interface이다.<br />
그러한 방식으로 구현이 되려면 다음의 개념이 필요하다.<br />
- 누가(어떤 thread가) 해당 actor를 도맡아서 주기적으로 act() 함수를 불러주는가?<br />
<br />
결국 thread를 관리하고, 각 thread에게 (대충) 공평하게 actor를 분배하고, 각 thread는 담당하는 actor를 처리하는 구조를 작성하여야 한다. 이에 대해서는 다음과 같은 개념으로 구현을 하였다.<br />
- <strong>시나리오</strong>를 통해 어떤 actor가 등장할지 각 thread에게 전달된다.<br />
- 각 <strong>일꾼(worker-thread)</strong>들은 시나리오를 보고 자기가 담당해야 할 역할(actor)을 기억한다.<br />
- 각 <strong>일꾼(worker-thread)</strong>들은 자기가 연기할 대상(actor)을 주기적으로 연기(act)한다.<br />
<br />
해서 scenario, worker, 그리고 worker를 관리하기 위한 worker_pool class가 등장하였다.<br />
<pre class="brush: cpp; html-script: true">class scenario_t {<br />
public:<br />
    typedef std::function<tick_actor_t* ()> tick_actor_factory_t;<br />
    typedef concurrency::concurrent_queue<tick_actor_factory_t> tick_actor_factory_queue_t;<br />
<br />
    scenario_t(int worker_count)<br />
        : _worker_count(worker_count) {<br />
        _worker_sched_index = 0;<br />
        _tick_actor_factory_queue_array = new tick_actor_factory_queue_t[worker_count];<br />
    }<br />
    ~scenario_t() {<br />
        delete[] _tick_actor_factory_queue_array;<br />
    }<br />
    int get_worker_count() const { return _worker_count; }<br />
    void enter(tick_actor_factory_t factory) {<br />
        int current_sched_index = _worker_sched_index++ % _worker_count;<br />
        _tick_actor_factory_queue_array[current_sched_index].push(factory);<br />
    }<br />
    tick_actor_factory_queue_t& get_factory_queue(int index) {<br />
        assert(index >= 0 && index < _worker_count);<br />
        return _tick_actor_factory_queue_array[index];<br />
    }<br />
private:<br />
    int _worker_count;<br />
    std::atomic_int _worker_sched_index;<br />
    tick_actor_factory_queue_t* _tick_actor_factory_queue_array;<br />
};</pre><br />
scenario class는 일꾼(worker)의 총 수가 몇 명인지 가지고 있다가, 어떤 배역(actor)이 등장(enter)하게 될 경우 round-robin 방식으로 각 worker와 연결된 queue에 배역 생성기(actor)를 넣어준다.<br />
<br />
<pre class="brush: cpp; html-script: true">class worker_t {<br />
public:<br />
    worker_t(scenario_t& scenario, int index)<br />
        : _scenario(scenario), _index(index) {}<br />
    void work() {<br />
        typedef std::vector<tick_actor_t*> tick_actors_t;<br />
        tick_actors_t tick_actors;<br />
        auto& factory_queue = _scenario.get_factory_queue(_index);<br />
        while (true) {<br />
            scenario_t::tick_actor_factory_t factory;<br />
            while (factory_queue.try_pop(factory)) {<br />
                auto* new_actor = factory();<br />
                tick_actors.push_back(new_actor);<br />
            }<br />
            for (auto it = tick_actors.begin(); it != tick_actors.end(); ++it) {<br />
                auto& actor = *(*it);<br />
                actor.post(&tick_actor_t::act);<br />
            }<br />
        }<br />
    }<br />
private:<br />
    int _index;<br />
    scenario_t& _scenario;<br />
};</pre><br />
worker class에서는 자신에게 할당된 (scenario에서 enter하면 추가되는) 배역 생성 queue를 확인하여 새로 부여받은 배역(actor)이 있나 확인하여 자신이 관리하는 vector에 넣는다.<br />
그리고 자신이 관리하는 모든 배역(actor)에 대해 act() 함수를 호출함으로써 각자의 act() 함수가 호출될 수 있도록 한다.<br />
<br />
<pre class="brush: cpp; html-script: true">class worker_pool_t {<br />
public:<br />
    worker_pool_t(scenario_t& scenario)<br />
        : _scenario(scenario) { employ(); }<br />
    ~worker_pool_t() {<br />
        finalize();<br />
    }<br />
private:<br />
    void employ() {<br />
        for (int index = 0; index < _scenario.get_worker_count(); ++index) {<br />
            _workers.push_back(std::thread([this, index] () {<br />
                worker_t worker(_scenario, index);<br />
                worker.work();<br />
            }));<br />
        }<br />
    }<br />
    void finalize() {<br />
        for (auto& each : _workers) {<br />
            each.join();<br />
        }<br />
        _workers.clear();<br />
    }<br />
private:<br />
    scenario_t& _scenario;<br />
    std::vector<std::thread> _workers;<br />
};</pre><br />
그리고 worker_pool class에서 각 worker에 thread를 부여하고 이것들을 관리할 수 있도록 간단히 코드를 작성하였다.<br />
<br />
#<br />
기반 코드 작성이 끝났으니 먹깨비와 제빵사를 구현해보자.<br />
tick_actor class의 act() 함수만 채우면 되니 간단하다.<br />
<pre class="brush: cpp; html-script: true">class baker_t : public tick_actor_t {<br />
public:<br />
    baker_t(basket_t& basket)<br />
        : _basket(basket) {}<br />
    virtual void act() {<br />
        auto locker = _basket.lock();<br />
        if (_basket.count() >= 20) {<br />
            return;<br />
        }<br />
        _basket.add();<br />
    }<br />
private:<br />
    basket_t& _basket;<br />
};</pre><br />
<pre class="brush: cpp; html-script: true">class eater_t : public tick_actor_t {<br />
public:<br />
    eater_t(basket_t& basket)<br />
        : _basket(basket) {}<br />
    virtual void act() {<br />
        auto locker = _basket.lock();<br />
        if (_basket.count() <= 0) {<br />
            return;<br />
        }<br />
        _basket.sub();<br />
    }<br />
private:<br />
    basket_t& _basket;<br />
};</pre><br />
각자는 act() 함수에서 자신이 참조하는 바구니에 lock()을 걸고, 문제의 제약조건에 따라 count()를 확인한 뒤 add() or sub()을 수행한다.<br />
<br />
여기까지 만들고 보면 결국 공유 자원은 lock으로 보호되고, actor간의 message 통신이 없으므로 post() 함수가 무의미해졌다는 사실을 깨달을 수 있게 된다!<br />
<br />
#<br />
이제 main 함수에서 판을 구성해보자.<br />
<pre class="brush: cpp; html-script: true">int _tmain(int argc, _TCHAR* argv[])<br />
{<br />
    scenario_t scenario(std::thread::hardware_concurrency());<br />
    worker_pool_t pool(scenario);<br />
<br />
    basket_t basket;<br />
    for (int index = 0; index < 10; ++index)<br />
        scenario.enter([&basket] () { return new baker_t(basket); });<br />
    for (int index = 0; index < 10; ++index)<br />
        scenario.enter([&basket] () { return new eater_t(basket); });<br />
<br />
    return 0;<br />
}</pre><br />
scenario를 먼저 만든다. 일꾼(worker) 수는 하드웨어가 지원하는 thread 개수로 지정한다.<br />
이제 만들어진 scenario 객체로 worker_pool 객체를 만들면 일꾼들이 고용(employ)되어 준비가 완료된다.<br />
<br />
배역들을 등장시키기 위해 scenario의 enter() 함수를 불러준다. 생성하는 코드 자체를 template 등으로 감쌀수도 있겠지만 그러면 코드가 복잡해지니 간단히 lambda로 구현한 factory method를 전달하였다. 이제 제빵사와 먹깨비가 round-robin 방식으로 각 worker에게 배정되어 관리될 것이다.<br />
<br />
#<br />
간단한 내용을 무의미하게 길게 코딩하는 법을 소개해 보았다.<br />
처음 과제 자체가 actor model에 익숙해지는 것을 위해 multi-thread 동기화 예제를 좀 무리하게 냈던 것인데,<br />
스터디에 참여했단 다른 친구들이 나처럼 의미없는 actor model을 구현하지 않고 재미있는 model을 구현해 주어서 참 다행이었다-_-;<br />

				</div>
                <hr>

                <!-- the comments -->
				<div id="disqus_thread"></div>
				<script type="text/javascript">
					/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
					var disqus_shortname = 'lacti'; // required: replace example with your forum shortname

					/* * * DON'T EDIT BELOW THIS LINE * * */
					(function() {
						var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
						dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
						(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
					})();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
				<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

            </div>

            <div class="col-lg-4">

                <div class="well">
					<h4>Related</h4>
					<ul>
						<li><a href="/a/여의도_스터디_과제_풀이__1.html">여의도 스터디 과제 풀이 #1</a> <span class="date">8. 4.</span></li>
					</ul>
                </div>
                <!-- /well -->
                <div class="well">
					<h4>Recents <a href="/" class="show-all">(all)</a></h4>
					<ul>

						<li><a href="/a/패킷_enum에_따른_packet_콜백_함수_자동생성.html">패킷 enum에 따른 packet 콜백 함수 자동생성</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴__2.html">비동기 프로그래밍 패턴 #2</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴.html">비동기 프로그래밍 패턴</a> <span class="date">10. 9.</span></li>
						<li><a href="/a/websocket,_webRTC.html">websocket, webRTC</a> <span class="date">9. 7.</span></li>
						<li><a href="/a/여의도_스터디_정리__4.html">여의도 스터디 정리 #4</a> <span class="date">8. 26.</span></li>
						<li><a href="/a/여의도_스터디_정리__3.html">여의도 스터디 정리 #3</a> <span class="date">8. 18.</span></li>
						<li><a href="/a/여의도_스터디_과제_풀이__2.html">여의도 스터디 과제 풀이 #2</a> <span class="date">8. 12.</span></li>
					</ul>
                </div>
                <!-- /well -->
				<gcse:search></gcse:search>
            </div>
        </div>

        <hr>

        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; lacti 2014</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- JavaScript -->
    <script src="../js/jquery-1.10.2.js"></script>
    <script src="../js/bootstrap.js"></script>

	<script type='text/javascript'>
		SyntaxHighlighter.all();
	</script>

	<script>
	  (function() {
		var cx = '001870890642618183212:k8iqprsstre';
		var gcse = document.createElement('script');
		gcse.type = 'text/javascript';
		gcse.async = true;
		gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
			'//www.google.com/cse/cse.js?cx=' + cx;
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(gcse, s);
	  })();
	</script>
</body>

</html>
