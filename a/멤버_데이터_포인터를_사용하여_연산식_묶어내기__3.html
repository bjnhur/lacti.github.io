<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="blog">
    <meta name="author" content="lacti">

    <title>멤버 데이터 포인터를 사용하여 연산식 묶어내기 #3</title>

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/blog-post.css" rel="stylesheet">

	<!-- Syntax highlighter -->
    <link href="../css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
    <link href="../css/shCore.css" rel="stylesheet" type="text/css" />
</head>

<body>

    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">#</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="#about">About</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <div class="container">

        <div class="row">
            <div class="col-lg-8">

                <h2>멤버 데이터 포인터를 사용하여 연산식 묶어내기 #3</h2>
                <p>
                    <span class="glyphicon glyphicon-time"></span> Posted on October 07, 2012 at 1:20 PM</p>
                <hr>
                <div class="content">
#<br />
지난 두 개의 글에서 사용한 전략은, 멤버에 접근하기 위한 방법을 동일한 인터페이스로 맞춰서<br />
(첫 번째 글에서는 멤버 데이터 포인터, 두 번째 글에서는 멤버 함수 포인터)<br />
BuffType과 그 인터페이스를 대응시키는 방법을 사용하였다.<br />
<br />
동일한 인터페이스를 사용하기 위해서, 그들을 하나의 동일한 타입으로 지칭하는 방법을 사용하였고,<br />
그렇기 때문에 서로 다른 type, int 변수와 float 변수, 그리고 그에 대한 배열 변수가 있을 때에는 사용할 수 없는 방법이었다.<br />
<pre class="brush: cpp">struct Stat {
    int hp;
    float attack;</pre><pre class="brush: cpp">typedef float Stat::*DataPtr;
DataPtr ptr = &Stat::hp; // Error!</pre><br />
이번 글에서는 형식 삭제(<a href="http://en.wikipedia.org/wiki/Type_erasure">type erasure</a>)를 사용하여 보다 다양한 type을 지원하면서, 확장 가능한 방법에 대해 알아보도록 하겠다.<br />
<br />
#<br />
형식 삭제라고 하면 뭔가 어려워 보이지만, 그 결과물을 보면 굉장히 친숙하다. C++에서 형식 삭제를 하는 방법은 가상 함수를 통한 다형성을 사용하는 것인데, 예를 들면 다음과 같다.<br />
<pre class="brush: cpp">struct ValueHolder {
    virtual float GetValue() const = 0;
    virtual void SetValue(float value) = 0;
}
struct IntValueHolder : public ValueHolder {
    virtual float GetValue() const { return static_cast&lt;float&gt;(value); }
    virtual void SetValue(float _value) { value = static_cast&lt;int&gt;(_value); }
    int value;</pre>
ValueHolder는 concrete class가 어떤 값을 들고 있던, GetValue() 함수를 통해 float type의 변수를 반환하도록 하거나, SetValue() 함수를 통해 float 값을 받아서 자신의 값을 변경하도록 할 수 있는 interface이다.<br />
<br />
#1, #2 글과 이어서 생각해 볼때, 위와 같은 방법을 사용하여 int, float, 혹은 그에 대한 배열 멤버 변수들을 Get, Set 할 수 있도록 구조를 잡으면 이 문제를 해결할 수 있다는 이야기이다.<br />
<br />
#<br />
그런데 왜 형식 삭제라는 골치 아픈 용어를 사용할까?<br />
char, short, int, long, float, double에 대한 모든 type에 대해 ValueHolder concrete class를 작성하는 것은 매우 귀찮은 일이다. 그렇다면 template을 사용하여 그 귀찮음을 해결해보자.<br />
<pre class="brush: cpp">template &lt;typename _Ty&gt;
struct ValueHolderImpl : public ValueHolder {
    virtual float GetValue() const { return static_cast&lt;float&gt;(value); }
    virtual void SetValue(float _value) { value = static_cast&lt;_Ty&gt;(_value); }
    _Ty value;</pre>
이제 ValueHolderImpl<> class를 사용하면 float type과 static_cast 호환이 되는 모든 형식에 대해 ValueHolder를 만들 수 있다.<br />
<pre class="brush: cpp">ValueHolder* intHolder = new ValueHolderImpl&lt;int&gt;;
ValueHolder* floatHolder = new ValueHolderImpl&lt;float&gt;;</pre>
concrete class들은 ValueHolderImpl<int> 와 같이 type 정보를 가진 채로 명시되지만 ValueHolder interface으로 지칭이 가능하다. 즉, runtime에는 concrete class의 type 정보 없이 그것들을 사용할 수 있게 되는 것이다.<br />
<br />
덕분에 서로 다른 type인 ValueHolderImpl<int>, ValueHolderImpl<float>에 대해 ValueHolder라는 공통된 접근을 할 수 있고, compile-time에 존재하던 형식 정보(type information)가 runtime에서 제거되었으므로 이를 형식 삭제라고 하는 것이다.<br />
<br />
#<br />
이제 필요한 이론을 모두 습득하였으니 즐거운 코딩을 해보자.<br />
형식 삭제를 위한 interface를 먼저 설계해보자.<br />
<pre class="brush: cpp">template &lt;typename _Class&gt;
class IAccessor {
public:
    virtual float GetValue(const _Class&) const = 0;
    virtual void SetValue(_Class&, float value) const = 0;
};</pre>
위 ValueHolder처럼 값을 넣고, 빼는 함수를 갖는다. 차이가 있다면, 이 Accessor 들은 구체적인 값을 가지는 것(Holding)이 아니라 멤버 데이터 포인터를 갖고, 특정 Class의 instance를 인자로 받아 그 값을 넣고 빼는 구조라는 것이다.<br />
좀 일반적인 설계를 위해, 어떤 class에 대한 Accessor를 만들 것인지를 template parameter로 남겨두었다.<br />
<br />
배열이 아닌 type에 대한 Accessor를 보면 이해하기가 쉽겠다. 다음 코드를 보자.<br />
<pre class="brush: cpp">template &lt;typename _Class, typename _Ty&gt;
class SingleAccessor : public IAccessor&lt;_Class&gt; {
public:
    virtual float GetValue(const _Class& obj) const {
        return static_cast&lt;float&gt;(obj.*dataPtr); 
    }
    virtual void SetValue(_Class& obj, float value) const {
        obj.*dataPtr = static_cast&lt;_Ty&gt;(value);
    }
    SingleAccessor(_Ty _Class::*_dataPtr)
        : dataPtr(_dataPtr) {}
private:
    _Ty _Class::*dataPtr;
};</pre>
생성자로 멤버 데이터 포인터를 받는다. 그리고 그 멤버 데이터 포인터가 어떤 type일지는 template parameter로 남겨둔다. 그리고 Get/SetValue 함수에서 object를 받아 자신이 가지고 있는 멤버 데이터 포인터를 사용하여 값을 가져오거나, 지정하는 작업을 수행한다.<br />
<br />
이제 이 SingleAccessor를 사용하여 int 변수이든, float 변수이든 멤버 변수의 type에 상관없이 접근할 수 있는 IAccessor를 만들 수 있는 것이다.<br />
<br />
멤버 변수의 타입이 배열인 것은 배열에 대한 크기와, 몇 번째 element에 접근할지에 대한 index 값이 같이 필요하다.<br />
<pre class="brush: cpp">template &lt;typename _Class, typename _Ty, size_t _Size&gt;
class ArrayAccessor : public IAccessor&lt;_Class&gt; {
public:
    virtual float GetValue(const _Class& obj) const {
        return static_cast&lt;float&gt;((obj.*arrayPtr)[index]);
    }
    virtual void SetValue(_Class& obj, float value) const {
        (obj.*arrayPtr)[index] = static_cast&lt;_Ty&gt;(value);
    }
    typedef std::array&lt;_Ty, _Size&gt; _Class::*ArrayPtrType;
    ArrayAccessor(ArrayPtrType _arrayPtr, int _index)
        : arrayPtr(_arrayPtr), index(_index) {}
private:
    ArrayPtrType arrayPtr;
    int index;
};</pre>
Get/SetValue 함수의 구조는 SingleAccessor와 크게 차이가 없다. 배열 타입의 멤버 데이터 포인터 변수와 index를 생성자로 받아서 가지고 있고, Get/SetValue 함수가 불리는 시점에 해당 배열의 위치에 접근하여 값을 가져오거나 넣는다.<br />
<br />
#<br />
이제 Accessor들과 enum 값을 연관지어 관리할 관리자를 만들어보자.<br />
<pre class="brush: cpp">template &lt;typename _Class&gt;
class AccessorManager {
public:
    typedef std::shared_ptr&lt;IAccessor&lt;_Class&gt;&gt; AccessorImpl;
    typedef std::map&lt;int, AccessorImpl&gt; AccessorImplMap;

    template &lt;typename _Class, typename _Ty&gt;
    void Register(int type, _Ty _Class::*dataPtr) {
        implMap.insert(std::make_pair(type, new SingleAccessor&lt;_Class, _Ty&gt;(dataPtr)));
    }
    template &lt;typename _Class, typename _Ty, size_t _Size&gt;
    void Register(int type, std::array&lt;_Ty, _Size&gt; _Class::*arrayPtr, int index) {
        implMap.insert(std::make_pair(type,
            new ArrayAccessor&lt;_Class, _Ty, _Size&gt;(arrayPtr, index)));
    }
    AccessorImpl operator [] (int type) {
        assert(implMap.find(type) != implMap.end());
        return implMap[type];
    }
private:
    AccessorImplMap implMap;
};</pre>
AccessorManager는 int (BuffType)와 shared_ptr<IAccessor>의 map을 갖고 이들을 Register 해주거나 enum 값으로 IAccessor를 찾아주는 작업을 한다.<br />
<br />
재미있는 것은 Register 함수들인데, Register 함수의 인자로 들어오는 값을 통해 template parameter들이 deduce되고, 이렇게 deduce된 template parameter들을 SingleAccessor나 ArrayAccessor의 template parameter로 넘겨주게 된다.<br />
<br />
이제 다음과 같이 쓸 수 있다.<br />
<pre class="brush: cpp">AccessorManager&lt;Stat&gt; manager;
manager.Register(BUFF_HP, &Stat::hp);
manager.Register(BUFF_RUN_SPEED, &Stat::movingSpeed, MST_RUN);</pre>
첫 번째 Register 호출은 SingleAccessor를 생성하는 Register 함수가 호출된다. 그리고 hp 멤버의 type이 적절히 deduce되어 SingleAccessor가 만들어진다.<br />
<br />
두 번째 Register 호출은 ArrayAccessor를 생성하는 Register 함수가 호출된다. 그리고 movingSpeed 멤버 type과 배열의 크기가 적절히 deduce되어 ArrayAccessor가 만들어진다.<br />
이 때 index인 MST_RUN이 같이 ArrayAccessor로 전달되어, BUFF_RUN_SPEED에 의해서 movingSpeed[MST_RUN]의 값을 제어할 수 있게 되는 것이다.<br />
<br />
생각해보니, 이러한 Manager class는 전역으로 하나만 있으면 좋겠다. 따라서 다음과 같이 간단한 singleton을 만들어서 써보자.<br />
<pre class="brush: cpp">template &lt;typename _Class&gt;
AccessorManager&lt;_Class&gt;& Accessor() {
    static AccessorManager&lt;_Class&gt; instance;
    return instance;
}</pre>
이는 thread-safe하지 않을 수 있는데, AccessorManager에 Register 하는 과정은 처음 프로그램이 초기화될 때 딱 한 번만 수행하면 되는 작업이고, 그 이후에는 전부 operator [] 로 access만 하면 되므로 thread-safe를 걱정할 필요는 없어 보인다.<br />
<br />
#<br />
이제 #2에서 정의한 BUFF_ENUM과 BUFF_ENUM_A 를 다음과 같이 정의하여 마무리를 지어보자.<br />
<pre class="brush: cpp">#define BUFF_ENUM(type, member) Accessor&lt;Stat&gt;().Register(type, member);
#define BUFF_ENUM_A(type, member, index) Accessor&lt;Stat&gt;().Register(type, member, index);
#include "BuffType.inl"
#undef BUFF_ENUM
#undef BUFF_ENUM_A</pre>
BuffType.inl의 내용은 #2와 동일하다. 이제 위와 같은 코드가 프로그램이 시작될 때 수행될 수 있도록 잘 배치해두면,<br />
(전역 구조체 변수의 생성자로 넣어놓는 방법 등을 사용하여)<br />
Stat 구조체 내의 변수와 BuffType을 엮을 수 있다는 것이다.<br />
<br />
#<br />
매번 AccessorManager에게 enum 값을 넘겨서 IAccessor를 받은 후, 그 IAccessor와 Stat 구조체 변수를 엮어서 값을 주고 받는 코딩을 하는 것은 너무 더럽고 귀찮다.<br />
따라서 간단히 이 둘을 연결해줄 수 있는 Accessible을 만들어보자.<br />
<pre class="brush: cpp">template &lt;typename _Class&gt;
class Accessible {
public:
    Accessible(_Class& _object)
        : object(_object) {}
    float GetValue(int type) {
        return Accessor&lt;_Class&gt;()[type]-&gt;GetValue(object);
    }
    void SetValue(int type, float value) {
        Accessor&lt;_Class&gt;()[type]-&gt;SetValue(object, value);
    }
    Accessible(const Accessible& that)
        : object(that.object) {}
private:
    Accessible& operator = (const Accessible&);
private:
    _Class& object;
};</pre>
Accessible은 class를 template parameter로 받고, IAccessor를 통해 접근할 object를 멤버로 갖는 class이다.<br />
그리고 Accessor<>를 통해 IAccessor를 불러와서 멤버로 가지고 있는 object와 연결하여 Get/SetValue를 할 수 있게 만들어준다. <br />
<br />
이제 다음과 같이 사용할 수 있다.<br />
<pre class="brush: cpp">Accessible&lt;Stat&gt; accessible(stat);
switch (buffMethod) {
case METHOD_SET: accessible.SetValue(buffType, buffValue); break;
case METHOD_ADD: accessible.SetValue(buffType, accessible.GetValue(buffType) + buffValue); break;
case METHOD_RATE: accessible.SetValue(buffType, accessible.GetValue(buffType) * buffValue); break;
}</pre>
<br />
#<br />
그렇다면 이것이 지난 번 방법에 비해 왜 더 느릴까?<br />
지난 #1, #2 방법들은 멤버 데이터 포인터나 멤버 함수 포인터를 사용하여 객체의 지정된 값을 가져오거나 지정하는 방법이었다. 만약 Stat 구조체가 POD 형태라면, 이들은 offset에 의한 데이터 접근을 하게 되거나 function-call 1번 수행(그나마도 inline 화 될 수 있는)하면 끝나는 형태이다.<br />
<br />
그렇지만 #3에 소개된 방법은 IAccessor라는 interface를 통해 concrete의 동작을 위해 vfptr을 사용하는 방식으로 가상 함수 호출을 위한 부담을 추가로 가지게 되는 것이다.<br />
이 호출 부담 때문에 더 느릴 수 밖에 없는 것이다.<br />
<br />
#<br />
다 쓰고 보니, AccessorManager가 굳이 map을 사용하지 않고, BUFF_MAX를 받아 배열로 IAccessor를 관리하는 것이 더 낫겠다 싶다.<br />
하지만 굳이 위와 같이 냅둔 이유는 <a href="/a/c++에서_reflection_사용하기__3.html">c++에서 reflection 사용하기 #3</a>와 형식이 유사해지기 때문에 코드 읽기가 좀 더 나을지도 모르겠다는 생각과,<br />
AccessorManager에서 배열의 크기를 template parameter로 받아서 배열을 생성해주기 약간 귀찮았기 때문이다-_-a<br />

				</div>
                <hr>

                <!-- the comments -->
				<div id="disqus_thread"></div>
				<script type="text/javascript">
					var disqus_shortname = 'lacti';
					(function() {
						var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
						dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
						(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
					})();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
				<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

            </div>

            <div class="col-lg-4">

                <div class="well">
					<h4>Related</h4>
					<ul>
						<li><a href="/a/멤버_데이터_포인터를_사용하여_연산식_묶어내기__1.html">멤버 데이터 포인터를 사용하여 연산식 묶어내기 #1</a> <span class="date">10. 1.</span></li>
						<li><a href="/a/멤버_데이터_포인터를_사용하여_연산식_묶어내기__2.html">멤버 데이터 포인터를 사용하여 연산식 묶어내기 #2</a> <span class="date">10. 3.</span></li>
					</ul>
                </div>
                <!-- /well -->
                <div class="well">
					<h4>Recents <a href="/" class="show-all">(all)</a></h4>
					<ul>

						<li><a href="/a/패킷_enum에_따른_packet_콜백_함수_자동생성.html">패킷 enum에 따른 packet 콜백 함수 자동생성</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴__2.html">비동기 프로그래밍 패턴 #2</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴.html">비동기 프로그래밍 패턴</a> <span class="date">10. 9.</span></li>
						<li><a href="/a/websocket,_webRTC.html">websocket, webRTC</a> <span class="date">9. 7.</span></li>
						<li><a href="/a/여의도_스터디_정리__4.html">여의도 스터디 정리 #4</a> <span class="date">8. 26.</span></li>
						<li><a href="/a/여의도_스터디_정리__3.html">여의도 스터디 정리 #3</a> <span class="date">8. 18.</span></li>
						<li><a href="/a/여의도_스터디_과제_풀이__2.html">여의도 스터디 과제 풀이 #2</a> <span class="date">8. 12.</span></li>
					</ul>
                </div>
                <!-- /well -->
				<gcse:search></gcse:search>
            </div>
        </div>

        <hr>

        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; lacti 2014</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- JavaScript -->
    <script src="../js/jquery-1.10.2.js"></script>
    <script src="../js/bootstrap.js"></script>

	<script>
	  (function() {
		var cx = '001870890642618183212:k8iqprsstre';
		var gcse = document.createElement('script');
		gcse.type = 'text/javascript';
		gcse.async = true;
		gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
			'//www.google.com/cse/cse.js?cx=' + cx;
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(gcse, s);
	  })();
	</script>
	
    <script src="../js/shCore.js" type="text/javascript"></script>
    <script src="../js/shAutoloader.js" type="text/javascript"></script>
	<script>
		if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
			// do nothing
		} else {
			SyntaxHighlighter.autoloader(
			  'bash shell             ../js/shBrushBash.js',
			  'cpp c                  ../js/shBrushCpp.js',
			  'c# c-sharp csharp      ../js/shBrushCSharp.js',
			  'css                    ../js/shBrushCss.js',
			  'java                   ../js/shBrushJava.js',
			  'js jscript javascript  ../js/shBrushJScript.js',
			  'php                    ../js/shBrushPhp.js',
			  'text plain             ../js/shBrushPlain.js',
			  'py python              ../js/shBrushPython.js',
			  'ruby rails ror rb      ../js/shBrushRuby.js',
			  'sql                    ../js/shBrushSql.js',
			  'xml xhtml xslt html    ../js/shBrushXml.js'
			);
			SyntaxHighlighter.defaults['toolbar'] = false;
			SyntaxHighlighter.all();
		}
	</script>
</body>

</html>
