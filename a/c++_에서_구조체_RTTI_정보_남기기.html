<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="blog">
    <meta name="author" content="lacti">

    <title>c++ 에서 구조체 RTTI 정보 남기기</title>
	<link href="http://yui.yahooapis.com/pure/0.3.0/grids-min.css" rel="stylesheet">
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shCore.css' rel='stylesheet' type='text/css' />
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css' rel='stylesheet' type='text/css' />
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushXml.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJScript.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCSharp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCpp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJava.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushBash.js' type='text/javascript'></script>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.css" rel="stylesheet">

    <!-- Add custom CSS here -->
    <link href="../css/blog-post.css" rel="stylesheet">

</head>

<body>

    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">#</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="#about">About</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <div class="container">

        <div class="row">
            <div class="col-lg-8">

                <!-- the actual blog post: title/author/date/content -->
                <h1>c++ 에서 구조체 RTTI 정보 남기기</h1>
                <p>
                    <span class="glyphicon glyphicon-time"></span> Posted on September 30, 2011 at 3:03 AM</p>
                <hr>
                <div class="content">
#<br />
libsora님의 글에 대한 답안 제출.<br />
졸린데 억지로 생각하다보니 별로 깨끗하지는 않다.<br />
<br />
#<br />
RTTI 는 Run-time Type Information 의 약자로, 실행 중에 어떤 type 에 대한 정보를 알 수 있다는 것이다.<br />
보통 type 에 대한 정보는 컴파일 타임에 다 사용되고, 실행 중에는 없어지는데,<br />
실행 중에 이 정보를 얻을 수 있으면 재밌는 일을 많이 할 수 있다.<br />
<br />
Java 나 C#, 아니면 여타 동적 언어들은 당연히 이 기능을 지원하고 (보통 reflection 이라고 한다)<br />
C, C++ 은 당연히 지원 안한다. 실행 중에 뭔가 정보를 더 남긴다는 것은 메모리도 많이 먹고 참조하려면 속도도 느려지니까!<br />
<br />
그래서 병후가 이야기한 것과 같은 일을 하려면,<br />
즉 구조체에 있는 정보만으로 xml read/write 가 자동으로 이루어지려면,<br />
1) 타입 정보를 runtime 에 접근해서 동적으로 read/write 를 한다.<br />
2) xml read/write 코드를 generator 를 통해 찍어낸다.<br />
<br />
보통 성능을 위해 2번을 쓰지만 병후는 매크로 덕후이므로 1번을 택했다.<br />
<br />
#<br />
RTTI 는 string 을 통해 각 정보를 가져오는 것이므로 먼저 char, wchar 로부터 자유로워야 한다.<br />
<pre class="brush: cpp; html-script: true">namespace std<br />
{<br />
    typedef wstring  tstring;<br />
    typedef wostream tostream;<br />
    typedef wistream tistream;<br />
}</pre><br />
<br />
#<br />
간단하게 type 의 종류를 정의해보자. 여러 타입이 있겠지만 귀찮으니까 int, float 만 정의하자.<br />
<pre class="brush: cpp; html-script: true">enum type_t { NONE, INT, FLOAT };</pre><br />
<br />
구조체의 각 변수 정보를 남기기 위해 그 정보를 저장할 자료를 선언하자.<br />
<pre class="brush: cpp; html-script: true">struct var_info<br />
{<br />
    var_info (const std::tstring& _name, const type_t& _type, size_t _offset)<br />
        : name (_name), type (_type), offset (_offset) {}<br />
<br />
    var_info (const var_info& o)<br />
        : name (o.name), type (o.type), offset (o.offset) {}<br />
<br />
    std::tstring name;<br />
    type_t       type;<br />
    size_t       offset;<br />
};<br />
typedef std::map<std::tstring, var_info> varmap_t;</pre><br />
<br />
구조체 내의 변수의 이름과 타입 정보를 갖는 것은 당연하다.<br />
그런데 offset 이라는 정보도 필요하다. 왜냐하면, xml read 를 수행할 때, 읽은 데이터를 객체의 <strong>어느 공간</strong> 에 넣어야 할 지 그 위치를 계산해서 넣어야 하기 때문에,<br />
메모리 상에 그 변수가 객체의 시작 지점으로부터 얼마만큼 떨어져서 위치하는가를 알고 있어야 한다.<br />
<br />
#<br />
이제 구조체 정보를 저장해보자.<br />
<pre class="brush: cpp; html-script: true">struct struct_info<br />
{<br />
    struct_info (const std::tstring& _name) : name (_name) {}<br />
    struct_info (const struct_info& o) : name (o.name) {}<br />
    struct_info () {}<br />
<br />
    std::tstring name;<br />
    varmap_t varmap;<br />
};</pre><br />
<br />
그냥 단순히 구조체에 대한 이름과 구조체에 대한 변수 목록을 map 객체로 갖고 있다.<br />
<br />
#<br />
rtti 라는 단순한 객체를 정의해보자. 단순히 이건 각 구조체 이름에 대응되는 struct_info 객체를 갖고 있으면 되니까 map 이면 충분하다.<br />
<pre class="brush: cpp; html-script: true">typedef std::map<std::tstring, struct_info> rtti_t;<br />
rtti_t rtti;</pre><br />
<br />
#<br />
구조체 내의 어떤 변수가 구조체 객체의 시작 주소로부터 얼마나 떨어져 있나를 계산하는 것은 간단하다.<br />
시작 주소를 0으로 만든 뒤 그 변수의 주소를 가져오면 되기 때문이다. 따라서 다음과 같은 매크로를 만들 수 있다.<br />
<pre class="brush: cpp; html-script: true">#define OFFSET_OF(_struct, _var) ((size_t) &(((_struct *) NULL)->_var))</pre><br />
<br />
NULL 을 구조체 주소로 casting 해서 그 변수를 접근한다. 하지만 접근해서 값을 쓰는게 아니라 단순히 & 연산자로 주소 값만 얻으니까 access violation 은 없다. 그리고 저 주소 값이 얼마만큼 떨어졌는지의 값(offset) 이다.<br />
<br />
#<br />
이제 구조체를 정의하는 매크로를 만들어야 한다.<br />
이게 약간 문제가 있는데, 병후의 요구 사항은 이와 같다.<br />
<pre class="brush: cpp; html-script: true">STRUCT_BEGIN(SampleStruct)<br />
    STRUCT_VAR_FLOAT(SampleStruct, a)<br />
    STRUCT_VAR_INT(SampleStruct, b)<br />
STRUCT_END()</pre><br />
<br />
보통 프로그램의 시작과 함께 초기화되는 정보를 구성할 경우에는 전역 변수를 많이 쓴다.<br />
예를 들면,<br />
<pre class="brush: cpp; html-script: true">struct __temp {<br />
    __temp () { printf ("hello world!"); }<br />
} ___temp;</pre><br />
와 같이 __temp 라는 struct 를 정의해서 ___temp 라는 전역 변수를 만들었다.<br />
전역 변수는 프로그램이 시작될 때 초기화되고, 이 때 생성자가 불리면서 hello world 가 출력될 것이다.<br />
<br />
하지만 구조체 각 변수는 구조체의 { } scope 안에 존재하기 때문에 전역 변수를 사용할 수 없는 공간이다.<br />
따라서 좀 다른 방법을 써야한다.<br />
<br />
#<br />
구조체 내의 멤버 변수들은 구조체 객체가 처음 생성될 때, 그 생성자가 호출된다.<br />
예를 들면,<br />
<pre class="brush: cpp; html-script: true">struct Sample {<br />
    struct __temp {<br />
        __temp () { printf ("hello world"); }<br />
    } ___temp;<br />
};</pre><br />
위와 같이 Sample 구조체를 정의했다. 저 Sample 의 변수를 하나라도 만드는 순간,<br />
Sample 구조체 내의 변수들이 초기화된다. ___temp 변수도 초기화된다. 따라서 __temp 의 생성자가 호출된다. 따라서 Sample 구조체의 instance 를 만들 때 마다 우리는 hello world 를 볼 수 있을 것이다.<br />
<br />
중복 실행을 막으려면 어떻게 해야할까? 간단히 static 변수를 하나 쓰면 된다.<br />
<pre class="brush: cpp; html-script: true">struct Sample {<br />
    struct __temp {<br />
        __temp () { <br />
            static bool once = true;<br />
            if (once)<br />
                printf ("hello world");<br />
            once = false;<br />
        }<br />
    } ___temp;<br />
};</pre><br />
그러면 hello world 는 Sample 객체를 처음 만들 때는 나오겠지만 그 다음부터는 안 나올 것이다.<br />
이 방법을 사용하여 각 변수들까지 RTTI 에 등록할 것이다.<br />
<br />
#<br />
먼저 한 번만 등록하기 위한 매크로를 만들어보자.<br />
<pre class="brush: cpp; html-script: true">#define REGISTER_ONLY_ONCE(_rtti, _name, _info) \<br />
    static bool init = false; \<br />
    if (!init) \<br />
        _rtti.insert(std::make_pair(_T(#_name), _info)); \<br />
    init = true;</pre><br />
이 코드는 구조체와 구조체의 변수를 각각 RTTI 에 등록할 때 사용될 것이다.<br />
<br />
이제 구조체를 등록하는 매크로와 변수를 등록하는 매크로를 보자.<br />
<pre class="brush: cpp; html-script: true">#define REGISTER_RTTI_STRUCT(_name) \<br />
    REGISTER_ONLY_ONCE(rtti, _name, (struct_info (_T(#_name))))<br />
<br />
#define REGISTER_RTTI_VAR(_struct, _var, _type) \<br />
    REGISTER_ONLY_ONCE(rtti[_T(#_struct)].varmap, _var, (var_info (_T(#_var), _type, OFFSET_OF(_struct, _var))))</pre><br />
<br />
구조체를 등록하는 매크로는 전역 rtti map 객체에 struct_info 를 넣어준다.<br />
구조체의 변수를 등록하는 매크로는 자신이 속한 구조체 rtti 내의 varmap 객체에 var_info 를 넣어준다.<br />
<br />
구조체의 변수를 등록하려면, 결국 자기가 어느 struct 에 속한지를 알아야, 전역 rtti 에서 자신이 속한 struct_info 를 얻어와서 거기에 변수 정보(var_info) 를 등록할 수 있다는 것이다.<br />
이 때문에 병후의 매크로의 변수 선언부를 보면, STRUCT_VAR_FLOAT(SampleStruct, a) 와 같이 구조체의 이름과 변수의 이름이 같이 들어가는 것이다.<br />
<br />
#<br />
이제 기본 RTTI 등록 매크로가 완성되었으니, 구조체 선언 매크로와 구조체 변수 선언 매크로를 작성하면 된다.<br />
구조체 선언 매크로는 다음과 같다.<br />
<pre class="brush: cpp; html-script: true">#define STRUCT_BEGIN(_name)    \<br />
    struct _name \<br />
    {    \<br />
    private: \<br />
        struct __register_init { __register_init () { REGISTER_RTTI_STRUCT(_name); } } ___register_init; \<br />
    public: \<br />
        static const std::tstring& name() { static std::tstring __name(_T(#_name)); return __name; }</pre><br />
지정된 이름으로 구조체를 시작한다.<br />
멤버로 갖는 구조체의 생성자에서 RTTI 등록 매크로를 사용하여 구조체 정보를 등록하도록 한다.<br />
이왕이면 private 으로 만들어서 그 임시 변수는 접근을 못하게 하자.<br />
<br />
나중에 xml read / write 를 할 때 구조체의 이름으로부터 RTTI 정보를 얻어와야 하므로 static 함수로 그 이름을 반환하도록 한다. 구조체의 이름으로 static string 변수를 하나 선언해놓고 그걸 반환해준다.<br />
<br />
구조체 내 변수 선언 매크로는 다음과 같다.<br />
<pre class="brush: cpp; html-script: true">#define STRUCT_VAR(_struct, _var, _ctype, _type) \<br />
    public: \<br />
        _ctype _var; \<br />
    private: \<br />
        struct __register_##_var { __register_##_var () { REGISTER_RTTI_VAR(_struct, _var, _type); } } ___register_##_var; \<br />
    public:</pre><br />
<br />
인자로 받은 c-type 으로 public 변수를 선언하고, RTTI 에 등록하기 위한 임시 멤버 변수로 RTTI 등록 매크로를 불러준다.<br />
이제 저 기본 매크로를 이용하여 type 별 선언 매크로를 만든다.<br />
<pre class="brush: cpp; html-script: true">#define STRUCT_VAR_INT(_struct, _var)        STRUCT_VAR(_struct, _var, int, INT)<br />
#define STRUCT_VAR_FLOAT(_struct, _var)        STRUCT_VAR(_struct, _var, float, FLOAT)</pre><br />
<br />
마지막으로 구조체 선언을 닫아주어야 하므로 마무리 매크로를 만든다.<br />
<pre class="brush: cpp; html-script: true">#define STRUCT_END()    };</pre><br />
<br />
그러면 병후가 제시한 대로 매크로를 통해 RTTI 가 등록된 구조체를 선언할 수 있다.<br />
<pre class="brush: cpp; html-script: true">STRUCT_BEGIN(SampleStruct)<br />
    STRUCT_VAR_FLOAT(SampleStruct, a)<br />
    STRUCT_VAR_INT(SampleStruct, b)<br />
STRUCT_END()</pre><br />
<br />
저 SampleStruct 구조체는 a: float, b: int 변수를 가질 것이고, 그 정보들은 이름 문자열과 함께 rtti 변수에 저장될 것이다.<br />
<br />
#<br />
xml read / write 를 구현해보자.<br />
먼저, 저 Object 를 받았을 때 var_info 의 offset 을 사용하여 어떻게 각 변수를 접근하나 보자.<br />
<br />
offset 정보는 구조체의 시작 주소로부터 그 변수까지의 간격(거리)라고 했다.<br />
그러면 그 변수에 접근하려면,<br />
1) 구조체의 시작 주소를 구한다.<br />
2) 시작 주소에 offset 을 더한다.<br />
3) 그 주소를 변수의 pointer type 에 맞게 casting 한다.<br />
4) 그 pointer 를 dereferencing 해서 값을 넣거나 뺀다.<br />
<br />
여기서 주의해야 할 점은 구조체의 시작 주소를 구할 때, 그냥 & 연산자만 쓰는게 아니라 char * 으로 casting 을 해주어야 한다는 것이다. 왜냐하면 offset 이란건 시작 주소로부터 그 변수까지 떨어진 <strong바이트 수</strong> 인데,<br />
<br />
Object 시작 주소를 & 연산자로 구해놓고 그 포인터에  + 연산을 수행하면 <strong>그 주소는 Object 의 크기만큼 증가한다</strong> 따라서 바이트 단위로 증가시켜주기 위해 char * 로 casting 한다.<br />
(char * 와 int * 각각의 변수에 대해 + 연산자를 사용하면 증가하는 값이 다르다는 이야기인데, 다 알고 있겠지만 한 번 더 설명 해 봤다.)<br />
<br />
그러면 아래와 같은 매크로를 만들 수 있다.<br />
<pre class="brush: cpp; html-script: true">#define GET_VAR_ADDR(_ctype, _obj, _offset) ((_ctype *) (((char*) &_obj) + _offset))<br />
#define GET_VAR(_ctype, _obj, _offset) (*(GET_VAR_ADDR(_ctype, _obj, _offset)))</pre><br />
<br />
#<br />
xml write 를 먼저 만들어보자. std::ostream 을 쓸 예정이다.<br />
자주 입력해야하는 문자열은 미리 매크로로 만들어두자. 귀찮다.<br />
<pre class="brush: cpp; html-script: true">#define XML_START_TAG(name)        _T("<") << name << _T(">")<br />
#define XML_END_TAG(name)        _T("</") << name << _T(">")<br />
#define XML_TAB                    _T("\t")</pre><br />
<br />
그런데 ostream 은 뭐가 들어올지 모른다. 기본적으로 wostream 과 그냥 ostream 부터가 다르다.<br />
그러니까 template 을 쓴다. 그러면 << 연산자만 overloading 되어있는 모든 대상에 대해 이 함수를 쓸 수 있다.<br />
(저걸 overloading 하는 network 통신 용 객체가 있다면 네트워크로 바로 xml 이 써질 것이다.)<br />
<br />
그리고 xml 로 작성해야할 대상 객체로부터도 general 해야하므로 그것도 template 으로 정한다.<br />
<br />
그래서 함수를 만들면 아래와 같다.<br />
<pre class="brush: cpp; html-script: true">template <typename _stream, typename _struct><br />
bool xml_write(_stream& out, const _struct& obj)<br />
{<br />
    if (rtti.find(obj.name()) == rtti.end())<br />
        return false;<br />
<br />
    const struct_info& si = rtti[_struct::name()];<br />
    out << XML_START_TAG(si.name) << std::endl;<br />
    for (varmap_t::const_iterator i = si.varmap.begin(); i != si.varmap.end(); ++i)<br />
    {<br />
        const var_info& vi = i->second;<br />
        out << XML_TAB << XML_START_TAG(vi.name);<br />
        switch (vi.type)<br />
        {<br />
        case INT: out << GET_VAR(int, obj, vi.offset); break;<br />
        case FLOAT: out << GET_VAR(float, obj, vi.offset); break;<br />
        }<br />
        out << XML_END_TAG(vi.name) << std::endl;<br />
    }<br />
    out << XML_END_TAG(si.name) << std::endl;<br />
    return true;<br />
}</pre><br />
<br />
매우 간단하다. 멤버의 타입도 2개 밖에 없다고 한정지었고, 구조체 내의 구조체(nested struct)와 같은 구조도 전혀 고려하지 않았다.<br />
<br />
단순히 정의된 구조체의 name() 을 통해 구조체 이름을 얻어서 rtti 에 접근해 구조체 정보를 얻는다.<br />
거기서 각 멤버에 대한 정보를 순회하면서 그 값을 GET_VAR 로 가져와 인자로 받은 stream 객체에 값을 쓴다.<br />
<br />
#<br />
xml read 는 write 에 비해 훨씬 복잡해야한다.<br />
하지만 난 매우 피곤하고 제대로 된 xml parser 를 작성할 생각은 추호도 없다.<br />
<br />
먼저 배열의 개수를 얻는 매크로를 보자. 크기는 sizeof 로 얻을 수 있으니 개수를 얻으려면 아래와 같겠다.<br />
<pre class="brush: cpp; html-script: true">#define COUNT_OF(array)        (sizeof (array) / sizeof (array[0]))</pre><br />
<br />
자, 이제 모든 준비가 끝났으니 xml read 를 작성하자.<br />
이번에도 역시 입력 스트림과 값을 읽을 객체에 대해 template 인자로 받는다.<br />
<pre class="brush: cpp; html-script: true">template <typename _stream, typename _struct><br />
bool xml_read(_stream& in, _struct& obj)<br />
{<br />
    if (rtti.find(obj.name()) == rtti.end())<br />
        return false;<br />
<br />
    const struct_info& si = rtti[_struct::name()];<br />
    <br />
    TCHAR name[1024], value[1024];<br />
    in.ignore(1024, _T('>')); // ignore root node<br />
    for (varmap_t::const_iterator iter = si.varmap.begin(); iter != si.varmap.end(); ++iter)<br />
    {<br />
        in.ignore(1024, _T('<')); // ignore before start tag<br />
        in.getline(name, COUNT_OF(name), _T('>'));<br />
        in.getline(value, COUNT_OF (value), _T('<'));<br />
<br />
        const var_info& vi = si.varmap.find(std::tstring(name))->second;<br />
        switch (vi.type)<br />
        {<br />
        case INT: GET_VAR(int, obj, vi.offset) = _wtoi (value); break;<br />
        case FLOAT: GET_VAR(float, obj, vi.offset) = static_cast<float> (_wtof (value)); break;<br />
        }<br />
    }<br />
    return true;<br />
}</pre><br />
구조체의 이름으로 rtti 정보를 가져온다.<br />
xml 에 어떤 순서로 기록될지는 모르지만, 어쨌든 구조체 내 멤버만큼은 node 가 있겠지, 라고 가정했다.<br />
따라서 구조체 내 멤버 정보로 iteration 을 수행하는데, 사실 그냥 개수만 세기 위한 훼이크다!<br />
<br />
istream 의 ignore 기능을 활용하여 쓸데 없는 whitespace 등을 무시하고,<br />
getline 함수의 delim 을 적절히 활용하여 각 node 의 이름과 값을 얻어서,<br />
그 멤버 변수의 type 에 따라 GET_VAR 를 통해 그 값을 넣어준다.<br />
<br />
#<br />
그럼 아래와 같이 쓸 수 있다.<br />
<pre class="brush: cpp; html-script: true">int _tmain(int argc, _TCHAR* argv[]) {<br />
    SampleStruct s;<br />
    s.a = 1.0f;<br />
    s.b = 2;<br />
    xml_write(std::wcout, s);<br />
<br />
    std::wifstream in(_T("test.xml"));<br />
    if (in)<br />
        xml_read(in, s);<br />
    <br />
    xml_write(std::wcout, s);</pre><br />
<br />
재밌는 점은 구조체를 한 번도 만들지 않았다면 RTTI 정보도 없다는 것이다.<br />
(이러한 동작 방식은 자바와 매우 유사하다! 자바도 해당 클래스를 접근하기 전까지는 그 클래스 내부의 어떠한 정보도 로딩되지 않는다.)<br />
<br />
위 코드 전문은 첨부파일에 넣었다.<br />
<br />
#<br />
졸린데 억지로 참고 쓰느라고 코딩 컨벤션도 개판이고 내용도 개판인데<br />
아무튼 덕분에 재밌는 코딩을 했다.<br />
<br />
#<br />
아뿔싸! 뱀 게임 만들어야하는데!<br />

				</div>
                <hr>

                <!-- the comments -->
				<div id="disqus_thread"></div>
				<script type="text/javascript">
					/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
					var disqus_shortname = 'lacti'; // required: replace example with your forum shortname

					/* * * DON'T EDIT BELOW THIS LINE * * */
					(function() {
						var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
						dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
						(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
					})();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
				<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

            </div>

            <div class="col-lg-4">

                <div class="well">
					<h4>Recents <a href="/" class="show-all">(all)</a></h4>
					<ul>

						<li><a href="/a/패킷_enum에_따른_packet_콜백_함수_자동생성.html">패킷 enum에 따른 packet 콜백 함수 자동생성</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴__2.html">비동기 프로그래밍 패턴 #2</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴.html">비동기 프로그래밍 패턴</a> <span class="date">10. 9.</span></li>
						<li><a href="/a/websocket,_webRTC.html">websocket, webRTC</a> <span class="date">9. 7.</span></li>
						<li><a href="/a/여의도_스터디_정리__4.html">여의도 스터디 정리 #4</a> <span class="date">8. 26.</span></li>
						<li><a href="/a/여의도_스터디_정리__3.html">여의도 스터디 정리 #3</a> <span class="date">8. 18.</span></li>
						<li><a href="/a/여의도_스터디_과제_풀이__2.html">여의도 스터디 과제 풀이 #2</a> <span class="date">8. 12.</span></li>
					</ul>
                </div>
                <!-- /well -->
				<gcse:search></gcse:search>
            </div>
        </div>

        <hr>

        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; lacti 2014</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- JavaScript -->
    <script src="../js/jquery-1.10.2.js"></script>
    <script src="../js/bootstrap.js"></script>

	<script type='text/javascript'>
		SyntaxHighlighter.all();
	</script>

	<script>
	  (function() {
		var cx = '001870890642618183212:k8iqprsstre';
		var gcse = document.createElement('script');
		gcse.type = 'text/javascript';
		gcse.async = true;
		gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
			'//www.google.com/cse/cse.js?cx=' + cx;
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(gcse, s);
	  })();
	</script>
</body>

</html>
