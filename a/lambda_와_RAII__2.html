<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="blog">
    <meta name="author" content="lacti">

    <title>lambda 와 RAII #2</title>

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/blog-post.css" rel="stylesheet">

	<!-- Syntax highlighter -->
    <link href="../css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
    <link href="../css/shCore.css" rel="stylesheet" type="text/css" />
</head>

<body>

    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">#</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="#about">About</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <div class="container">

        <div class="row">
            <div class="col-lg-8">

                <h2>lambda 와 RAII #2</h2>
                <p>
                    <span class="glyphicon glyphicon-time"></span> Posted on May 12, 2012 at 3:52 PM</p>
                <hr>
                <div class="content">
#<br />
이전 글에서 다루지 못한 lambda 를 통한 lock 사용법과, 단위 전략을 통한 RAII 구현에 대해 살펴보자.<br />
<br />
#<br />
C++11 은 lambda expression 을 지원해주니 좀 다르게 생각해볼 수 있다.<br />
<pre class="brush: cpp">class lock_t {
public:
    template &lt;typename functor&gt;
    void scoped(functor& func) {
        lock();
        func();
        unlock();
    }
};</pre>
<br />
lock_t class 자체에 위와 같이 functor 를 받아 실행할 수 있는 함수를 만든다.<br />
그리고 그 앞 뒤로 lock-unlock 을 불러준다.<br />
<br />
이렇게 하면, lambda 를 사용하여 lock 사용 코드를 보다 깔끔하게 정리해볼 수 있다.<br />
<pre class="brush: cpp">item_ref inventory_t::find(item_id_t item_id) {
    item_ref item(NULL);
    lock.scoped([&item] () {
        auto iter = std::find(items.begin(), items.end(), find_item_by_id(item_id));
        if (iter != items.end())
            item = (*iter);
    });
    return item;
}</pre>
<br />
lambda 를 통해 lock 구문을 수행하는 코드를 보다 깔끔하게 묶어낼 수 있다... 라고 이야기하고 싶지만, item 이라는 값을 반환해야할 방법이 딱히 없어서 외부에서 변수를 선언하고 내부로 전달하는 영 좋지 못한 방법을 쓰고 있다.<br />
<br />
약간 이야기가 다른 길로 가지만, 보다 깔끔한 해결책을 위해 아래와 같이 코드를 작성해볼 수 있다는 것을 이야기하고 싶다.<br />
<pre class="brush: cpp">class lock_t {
public:
    template &lt;typename R, typename functor&gt;
    R&& scoped_return(functor&& func) {
        lock();
        R&& r = func();
        unlock();
        return std::move(r);
    }
};</pre>
<pre class="brush: cpp">item_ref inventory_t::find(item_id_t item_id) {
    return lock.scoped_return&lt;item_ref&gt;([=] () {
        auto iter = std::find(items.begin(), items.end(), find_item_by_id(item_id));
        return (iter != items.end())? (*iter): NULL;
    });
}</pre>
반환 값에 대해서도 일반화를 시켜주면 된다는 이야기다. 물론 값을 쓸데없이 복사하는 구간이 있는데, 저 부분은 다시 RAII 를 사용하여 묶는 등 코드를 좀 더 정리해볼 수 있겠다.<br />
(그게 귀찮아서 위처럼 r-value 를 썼는데, 어차피 move constructor 가 구현되어있지 않다면 저 방법은 효윺이 영 좋지 않을 수 있다.)<br />
<br />
#<br />
lambda 를 이용해 raii 영역을 하나의 scope 로 묶어주는 방법에 대해서 정리해봤다.<br />
하지만 이 방법을 써도, 결국 최종 지점 (위 예제에서는 scoped 함수) 에서는 결국 raii 를 사용하여 자원을 관리할 필요가 있게 된다.<br />
<br />
이러한 패턴은 생각보다 자주 등장하게 되므로, 이에 대한 일반적인 패턴을 만들어놓으면 좋을 것이다.<br />
이를 만족시키는 적절한 template class 를 작성해보자.<br />
<pre class="brush: cpp">template &lt;class _Ty, void (_Ty::*begin)(), void (_Ty::*end)()&gt;
class raii_t {
public:
    raii_t(_Ty* _obj)
        : obj(_obj) {
        (obj-&gt;*begin)();
    }
    ~raii_t() {
        (obj-&gt;*end)();
    }
private:
    _Ty* obj;
};</pre>
raii_t 라는 class 는 특정 type 과, 그 type 에 대해 시작 시 수행할 함수와 끝날 때 수행될 함수를 template 인자로 받는다.<br />
이제 lock_t 에 대한 lock_raii_t class 는 다음과 같은 typedef 로 정의할 수 있다.<br />
<pre class="brush: cpp">typedef raii_t&lt;lock_t, &lock_t::lock, &lock_t::unlock&gt; lock_raii_t;</pre>
<br />
lock_raii_t 는 lock_t 에 대해 동작하면서, 해당 변수가 생성 시 lock_t::lock 함수를 부르고, 소멸될 때 lock_t::unlock 함수를 부르게 된다.<br />
<pre class="brush: cpp">lock_t lock;
lock_raii_t raii(&lock);</pre>
<br />
저 raii_t 는 꽤 일반적이어서, 생성과 소멸 시 특정 함수를 통해 자원 관리가 되어야 하는 class 에 대해 모두 적용될 수 있다. 예를 들면 shared_ptr (add_ref/release_ref) 등이 될 수 있다.<br />
<br />
#<br />
민철 선배님께서 예제로 달았던 finalizer 를 raii 의 예로 들어보자.<br />
특정 scope 가 끝나는 시점에 수행되어야할 작업들을 명시해주는 객체가 된다.<br />
즉, 익명의 객체를 하나 만들고, 그 소멸자에서 수행될 함수를 인자로 받도록 한다.<br />
<br />
먼저, 소멸자에서 무언가를 수행해줄 수 있는 class 를 만들어보자.<br />
<pre class="brush: cpp">template &lt;typename _Func&gt;
struct finalizer {
    finalizer(_Func&& _func)
        : func(_func) {}
    ~finalizer() {
        func();
    }
private:
    _Func func;
};</pre>
보다 일반적인 함수 수행을 원한다면 (일반 함수, 함수자, 멤버 함수 등) std::function 등을 적절히 사용하는 것도 좋겠지만 본 예제에서는 간단히 위처럼 설계했다.<br />
위 finalizer class 는 생성자로 받은 함수를 소멸자에서 수행하므로, 해당 객체가 소멸될 때까지 인자로 받은 함수의 수행을 미루게 된다.<br />
<br />
이제 template argument 유추를 컴파일러에게 맡기기 위해 이 객체를 만들어주는 함수를 만들자.<br />
<pre class="brush: cpp">template &lt;typename _Func&gt;
finalizer&lt;_Func&gt; do_exit_scope(_Func&& func) {
    return finalizer&lt;_Func&gt;(std::move(func));
}</pre>
<br />
그러면 다음과 같이 사용이 가능해진다.<br />
<pre class="brush: cpp">auto f = do_exit_scope([=] () {
    // implements here!
});</pre>
<br />
생성된 객체가 소멸될 때 불려야한다는 것은, 불편하게도 auto f 와 같이 명시적으로 변수를 코드로 적어줘야 한다는 이야기다. 이왕이면 이런 것 정도는 자동으로 컴파일러가 해줬으면 좋겠다, 싶으니 약간의 장난을 쳐보자.<br />
<br />
솔직히 g++ 은 어떻게 해야 좋을지 모르겠고, __COUNTER__ macro 가 있는 msvc 기준으로 설명하겠다.<br />
__COUNTER__ 는 해당 매크로가 해석될 때마다 1씩 증가하는 predefined macro 이다. 따라서 임시 변수 명을 지어주기에는 적합한 녀석이다. (대체품으로 __LINE__ 를 쓰기도 한데, 이러면 한 줄에 여러 코드를 작성할 수 없다.)<br />
<br />
<pre class="brush: cpp">#define __concat(a, b)      a##b
#define __auto_var          __concat(_auto_var, __COUNTER__)
#define __do_exit_scope(f)  auto __auto_var = do_exit_scope(f)</pre>
__auto_var 매크로는 자동으로 변수의 이름을 대충 지어주는 매크로다. _auto_var 라는 prefix 를 붙이고, 뒤에 __COUNTER__ 를 붙여서 _auto_var1, _auto_var2 등으로 해당 매크로를 사용할 때마다 이름이 알아서 지어지도록 한다.<br />
<br />
__COUNTER__ 와 _auto_var 를 붙이기 위해서 ## 연산자를 썼다. 다만 이게 _auto_var##__COUNTER__ 처럼 사용하면 __COUNTER__ 이 문자열로 해석되므로 __concat 와 같은 다른 macro 를 만들어서 사용해야 한다.<br />
<br />
마지막으로 __do_exit_scope 라는 매크로 함수를 만들어서, 인자로 받은 함수에 대해 자동 변수 이름을 부여하도록 한다.<br />
이러면 auto f 와 같이 명시적으로 이름을 지정해주지 않아도 자동으로 변수를 할당하므로 조금이나마 더 나은 코드를 작성할 수 있다 (라는 기분이 든다-_-)<br />
<pre class="brush: cpp">__do_exit_scope([=] () { _tprintf_s(_T("third\n")); });
__do_exit_scope([=] () { _tprintf_s(_T("second\n")); });
__do_exit_scope([=] () { _tprintf_s(_T("first\n")); });</pre>
(변수의 소멸 순서는 생성 순서의 역순이므로, 출력 순서는 first - second - third 가 된다.)<br />
<br />
#<br />
다시 raii 이야기로 돌아와서,<br />
raii 기법은 단순히 생성자/소멸자 쌍에서 관리 대상 객체의 특정 함수 호출 쌍을 맞춰줌으로써 자원 관리에 문제가 없도록 해주는 기법이라 정리해볼 수 있겠다.<br />
<br />
이를 위해 자원이 사용되는 구간을 scope 로 한정 짓기 위해 lambda 를 사용하는 방법,<br />
그리고 generic 한 raii_t template class 를 구현하여 사용하는 방법에 대해 간단히 알아보았다.<br />
<br />
하지만 장문의 2개의 글에도 불구하고, 한가지 내용에 대해 다루지 않고 있는 것을 눈치가 빠른 분께서는 눈치를 챘을 것이다.<br />
그것은 바로 <strong>raii class 를 단위 전략 기법</strong>을 사용하여 설계하는 내용인데, 간단히 설명하면,<br />
<br />
1) raii 객체가 생성자로 관리할 객체의 주소를 인자로 받는데, 그냥 자신의 멤버 변수로 가지고 있으면 안되나?<br />
2) raii 객체가 생성자, 소멸자에서 호출될 함수를 모두 template 인자로 받는데, 위의 finalizer 예제 처럼 한 쪽에 대해 아무 동작을 수행하지 않도록 할 수 있는 다른 장치를 구현할 수 없을까?<br />
3) raii 객체의 복사/대입 가능성은 전혀 고려하지 않고 있는데, 이것에 대해서는 어떻게 다루는 것이 좋을까?<br />
4) raii 객체에 대해 multi-thread 에서 접근한다고 할 필요가 있을 수 있는데, 위 raii class 는 그런 관점에서는 일반적이라고 하기에는 무리가 있지 않을까?<br />
<br />
등등, storage, default template argument?, ownership, thread-safety 등 몇 가지 세부 구현 전략에 대해서 더 raii class 를 더 고민해볼 수 있는데, 이러한 것들을 <strong>단위 전략(policy)</strong> 이라고 불렀던 것이다(MC++D)<br />
<br />
이 내용은 굉장히 흥미롭겠지만, 여백이 부족하여 더 이상 적지 않는다.<br />

				</div>
                <hr>

                <!-- the comments -->
				<div id="disqus_container">
					<div id="disqus_thread"></div>
					<script type="text/javascript">
						var disqus_shortname = 'lacti';
						(function() {
							var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
							dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
							(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
						})();
					</script>
					<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
					<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
				</div>
            </div>

            <div class="col-lg-4 sides">

                <div class="well">
					<h4>Related</h4>
					<ul>
						<li><a href="/a/lambda_와_RAII.html">lambda 와 RAII</a> <span class="date">4. 1.</span></li>
						<li>lambda 와 RAII #2 <span class="date">5. 12.</span></li>
					</ul>
                </div>
                <!-- /well -->
                <div class="well">
					<h4>Recents <a href="/" class="show-all">(all)</a></h4>
					<ul>

						<li><a href="/a/패킷_enum에_따른_packet_콜백_함수_자동생성.html">패킷 enum에 따른 packet 콜백 함수 자동생성</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴__2.html">비동기 프로그래밍 패턴 #2</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴.html">비동기 프로그래밍 패턴</a> <span class="date">10. 9.</span></li>
						<li><a href="/a/websocket,_webRTC.html">websocket, webRTC</a> <span class="date">9. 7.</span></li>
						<li><a href="/a/여의도_스터디_정리__4.html">여의도 스터디 정리 #4</a> <span class="date">8. 26.</span></li>
						<li><a href="/a/여의도_스터디_정리__3.html">여의도 스터디 정리 #3</a> <span class="date">8. 18.</span></li>
						<li><a href="/a/여의도_스터디_과제_풀이__2.html">여의도 스터디 과제 풀이 #2</a> <span class="date">8. 12.</span></li>
					</ul>
                </div>
                <!-- /well -->
				<gcse:search></gcse:search>
            </div>
        </div>

        <footer>
			<hr>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; lacti 2014</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- JavaScript -->
    <script src="../js/jquery-1.10.2.js"></script>
    <script src="../js/bootstrap.js"></script>

	<script>
	  (function() {
		var cx = '001870890642618183212:k8iqprsstre';
		var gcse = document.createElement('script');
		gcse.type = 'text/javascript';
		gcse.async = true;
		gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
			'//www.google.com/cse/cse.js?cx=' + cx;
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(gcse, s);
	  })();
	</script>
	
    <script src="../js/shCore.js" type="text/javascript"></script>
    <script src="../js/shAutoloader.js" type="text/javascript"></script>
	<script>
		if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
			// do nothing
		} else {
			SyntaxHighlighter.autoloader(
			  'bash shell             ../js/shBrushBash.js',
			  'cpp c                  ../js/shBrushCpp.js',
			  'c# c-sharp csharp      ../js/shBrushCSharp.js',
			  'css                    ../js/shBrushCss.js',
			  'java                   ../js/shBrushJava.js',
			  'js jscript javascript  ../js/shBrushJScript.js',
			  'php                    ../js/shBrushPhp.js',
			  'text plain             ../js/shBrushPlain.js',
			  'py python              ../js/shBrushPython.js',
			  'ruby rails ror rb      ../js/shBrushRuby.js',
			  'sql                    ../js/shBrushSql.js',
			  'xml xhtml xslt html    ../js/shBrushXml.js'
			);
			SyntaxHighlighter.defaults['toolbar'] = false;
			SyntaxHighlighter.all();
		}
	</script>
</body>

</html>
