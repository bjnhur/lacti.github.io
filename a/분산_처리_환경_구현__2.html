<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="blog">
    <meta name="author" content="lacti">

    <title>분산 처리 환경 구현 #2</title>
	<link href="http://yui.yahooapis.com/pure/0.3.0/grids-min.css" rel="stylesheet">
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shCore.css' rel='stylesheet' type='text/css' />
    <link href='http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css' rel='stylesheet' type='text/css' />
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushXml.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJScript.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCSharp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCpp.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJava.js' type='text/javascript'></script>
    <script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushBash.js' type='text/javascript'></script>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.css" rel="stylesheet">

    <!-- Add custom CSS here -->
    <link href="../css/blog-post.css" rel="stylesheet">

</head>

<body>

    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">#</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="#about">About</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <div class="container">

        <div class="row">
            <div class="col-lg-8">

                <!-- the actual blog post: title/author/date/content -->
                <h1>분산 처리 환경 구현 #2</h1>
                <p>
                    <span class="glyphicon glyphicon-time"></span> Posted on May 07, 2013 at 12:25 AM</p>
                <hr>
                <div class="content">
#<br />
<a href="file/generation06/DistWork.zip">소스 코드 다운로드</a><br />
<br />
#<br />
지난 번 글에서는 분산 처리 환경에 대한 구조를 대충 알아봤다.<br />
이번 글에서는 대충 알아본 것 중 하나를 선택해서 C#으로 구현을 해볼 것이다.<br />
<br />
가장 간단해보이는 M-S 모델 (master-slave)을 C#으로 구현해보자.<br />
<br />
#<br />
일단 구현하기에 앞서 간단히 설계도를 살펴보자.<br />
<p style="text-align: center;"><a rel="lightbox[분산 처리 환경 구현 #2]" href="file/generation06/mdf_arch.png"><img src="file/generation06/mdf_arch.png" border="0" style="border: 1px solid black;" /></a></p><br />
<br />
master에는 여러 slave가 연결한다. 각 연결된 slave는 master 내에 어떤 작업을 수행하는지/했는지 info를 갖는다.<br />
master에 command가 들어오면 수행할 work를 만든다. 연결된 slave의 info를 살펴보고 적절한 slave를 선택한 후 work를 보내준다. <strong>(distribute)</strong> 그러면 slave는 그 작업을 처리하고 결과를 master에게 보내주던가 한다.<br />
<br />
위 구현을 위해서는,<br />
<pre class="brush: cpp; html-script: true">1) c# network programming 기술<br />
2) c# object serialization 기술</pre><br />
정도만 알면 된다.<br />
<br />
하지만 본 글에서 위 내용을 설명하는 것은 매우 무의미하기 때문에 이 부분에 대해서는 설명하지 않는다.<br />
자세한 내용은 <a href="file/generation06/DistWork.zip">소스 코드</a>의 AsyncSocketExtension.cs와 WorkSocketHelper.cs 파일을 보면 된다.<br />
<br />
#<br />
먼저 master와 slave가 주고 받을 작업의 추상 형태인 IWork interface부터 살펴보면 다음과 같다.<br />
<pre class="brush: csharp; html-script: true">public interface IWork<br />
{<br />
    void Execute(Socket endPoint);<br />
}</pre><br />
이 interface를 구현한 class가 Serializable하면 Master와 Slave간에 serialize/deserialize되어 전달될 수 있고,<br />
전달된 후에 Execute를 호출해주면 되므로 사실상 RPC와 같은 형태가 된다.<br />
이 때 endPoint의 Socket을 받는 이유는 수행한 결과에 대해 상대측으로 다시 결과를 전달하기 위함이다.<br />
(이는 마지막 예제에서 볼 수 있다.)<br />
<br />
#<br />
Master class는 Slave의 통신을 위한 Socket과, 각 Slave의 상태에 대한 Information을 갖는다.<br />
그리고 작업 분산이 요청될 경우(DistributeWork) 적절한 Slave의 Socket을 고르기 위한 알고리즘 함수를 갖는다.<br />
Java같은 언어라면 interface로 해당 알고리즘을 분리하겠지만, C#이니 그냥 delegate로 빼서 관리한다.<br />
<br />
위 구현 사항을 분할해서 살펴보자. 먼저 Slave와 연결을 맺고 Slave가 전달하는 Work를 처리하기 위한 함수이다.<br />
<pre class="brush: csharp; html-script: true">// Master class<br />
public async void Start()<br />
{<br />
    var listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br />
    var localEndPoint = new IPEndPoint(IPAddress.Any, _port);<br />
    try<br />
    {<br />
        listener.Bind(localEndPoint);<br />
        listener.Listen(100);<br />
        while (true)<br />
        {<br />
            var clientSocket = await listener.AcceptAsync();<br />
            ProcessSocket(clientSocket);<br />
        }<br />
    }<br />
    catch (Exception e) { Logger.Write(e); }<br />
}<br />
<br />
private async void ProcessSocket(Socket socket)<br />
{<br />
    _container.AddSocket(socket);<br />
<br />
    Logger.Write("Connected from: " + socket.RemoteEndPoint);<br />
    try<br />
    {<br />
        while (true)<br />
        {<br />
            var work = await socket.ReceiveWork();<br />
            work.Execute(socket);<br />
        }<br />
    }<br />
    catch (Exception e) { Logger.Write(e); }<br />
<br />
    try { socket.Shutdown(SocketShutdown.Both); }<br />
    catch { }<br />
    _container.RemoveSocket(socket);<br />
}</pre><br />
지정된 port에 bind된 socket이 Slave와 연결되면 그 Socket으로부터 Work를 하나씩 받아서(deserialize) 처리하는 형태이다.<br />
awaitable한 프로그램을 작성했기 때문에 managed thread pool이 적절히 잘 운영해준다.<br />
<br />
_container는 SocketContainer 객체로 slave의 socket을 관리해준다.<br />
SocketContainer에서 관리하는 Socket 집합은 추후 작업을 분산시키기 위해 특정 slave를 선택할 때 사용된다.<br />
<br />
#<br />
Slave는 Master에 연결한 뒤, 역시 동일하게 Master로부터 Work를 받아서 처리하는 구조로 작성하면 된다.<br />
때문에 이 부분은 Master의 코드와 크게 차이가 없다.<br />
<pre class="brush: csharp; html-script: true">public class Slave<br />
{<br />
    public async void Start()<br />
    {<br />
        try<br />
        {<br />
            var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream,<br />
                    ProtocolType.Tcp);<br />
            socket.Connect(_host, _port);<br />
            while (true)<br />
            {<br />
                var work = await socket.ReceiveWork();<br />
                work.Execute(socket);<br />
            }<br />
        }<br />
        catch (Exception e) { Logger.Write(e); }<br />
    }<br />
}</pre><br />
<br />
#<br />
Slave의 Socket을 관리하는 SocketContainer는, Slave의 연결이 동시 다발적으로 일어나므로 내부에 Lock을 가지고 Container를 관리하는 객체이다.<br />
<pre class="brush: csharp; html-script: true">// SocketContainer class<br />
ReaderWriterLockSlim _lock =<br />
    new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);<br />
private readonly Dictionary<Socket, SocketInformation> _sockets =<br />
    new Dictionary<Socket, SocketInformation>();<br />
<br />
public void AddSocket(Socket socket)<br />
{<br />
    _lock.DoWriteLock(() => _sockets.Add(socket, SocketInformation.Invalid));<br />
}<br />
<br />
public void RemoveSocket(Socket socket)<br />
{<br />
    _lock.DoWriteLock(() => _sockets.Remove(socket));<br />
}<br />
<br />
public Socket SelectSocket(Func<List<KeyValuePair<Socket, SocketInformation>>, Socket> selector)<br />
{<br />
    return _lock.DoReadLock(() => selector(_sockets.ToList()));<br />
}</pre><br />
약간이나마 효율을 높이기 위해 ReaderWriterLock을 사용했다.<br />
재미있는 부분은 SelectSocket을 수행하는 부분인데, 이 과정에서는 모든 Socket과 그에 대한 Information을 순회하면서 적절한 Socket을 뽑아내야한다. 하지만 해당 자료구조를 순회하려면 자료구조가 Lock으로 보호된 상태이어야 하므로 Socket을 선택하는 selector를 delegator 형태로 받아서 ReadLock 구역 내에서 수행될 수 있도록 한다.<br />
<br />
그런데 작업을 분산시키기 위해 필요한 정보는 Socket, SocketInformation 뿐만 아니라 어떤 작업인지(IWork)의 정보도 필요하다. 때문에 Master에서는 이 정보까지 취합해서 적절한 Slave를 선택할 수 있도록 delegator를 제공한다.<br />
<br />
<pre class="brush: csharp; html-script: true">public sealed class DistributeContext<br />
{<br />
    public readonly IList<KeyValuePair<Socket, SocketInformation>> Sockets;<br />
    public readonly IWork Work;<br />
    private readonly SocketContainer _container;</pre><br />
<pre class="brush: csharp; html-script: true">// Master class<br />
public delegate Socket SelectSocketDecl(DistributeContext context);<br />
private SelectSocketDecl _socketSelector;<br />
public void DistributeWork(IWork work)<br />
{<br />
    var socket = _container.SelectSocket(sockets =><br />
            _socketSelector(new DistributeContext(_container, sockets.AsReadOnly(), work)));<br />
    if (socket == null)<br />
        throw new NullReferenceException();<br />
<br />
    socket.SendWork(work);<br />
}</pre><br />
필요한 정보(Socket, SocketInformation, IWork)를 DistributeContext로 감싸서 SelectSocketDecl로 넘겨준다.<br />
이 delegator는 _container의 SelectSocket() 내에서 수행되므로 _container의 ReadLock 내에서 수행된다.<br />
이렇게 socket을 하나 선택하게 되면 해당 socket으로 work를 전달한다. 즉 해당 slave에게 work를 전달한다.<br />
<br />
#<br />
굉장히 간단한 구조로 분산 시스템을 만들어봤다.<br />
Master는 Slave의 연결을 기다리고, Slave가 연결되면 각 상태를 적절하게 고려해서 작업을 전달한다.<br />
Slave는 Master에게 연결한 뒤, Master의 작업을 기다리고 있다가 받는 즉시 처리해준다.<br />
<br />
소스 코드에 첨부된 간단한 예제 코드를 직접 보면 다음과 같다.<br />
<pre class="brush: csharp; html-script: true">[Serializable]<br />
internal class SlaveWork : IWork<br />
{<br />
    public void Execute(Socket endPoint)<br />
    {<br />
        Console.WriteLine("Do my work: " + endPoint.RemoteEndPoint);<br />
        endPoint.SendWork(new MasterWork(new SlaveResult("TEST MESSAGE")));<br />
    }<br />
}<br />
<br />
[Serializable]<br />
internal class SlaveResult<br />
{<br />
    public readonly string SlaveGeneratedMessage;<br />
<br />
    public SlaveResult(string message)<br />
    {<br />
        SlaveGeneratedMessage = message;<br />
    }<br />
}<br />
<br />
[Serializable]<br />
internal class MasterWork : IWork<br />
{<br />
    private readonly SlaveResult _result;<br />
<br />
    public MasterWork(SlaveResult result)<br />
    {<br />
        _result = result;<br />
    }<br />
<br />
    public void Execute(Socket endPoint)<br />
    {<br />
        Console.WriteLine("Do master work: " + endPoint.RemoteEndPoint);<br />
        Console.WriteLine("Received from slave: " + _result.SlaveGeneratedMessage);<br />
    }<br />
}<br />
<br />
internal class Program<br />
{<br />
    private static void Main(string[] args)<br />
    {<br />
        var master = new Master(12345);<br />
        Task.Factory.StartNew(master.Start);<br />
<br />
        Thread.Sleep(1000);<br />
<br />
        const int slaveCount = 10;<br />
        foreach (var index in Enumerable.Range(0, slaveCount))<br />
        {<br />
            var slave = new Slave("127.0.0.1", 12345);<br />
            Task.Factory.StartNew(slave.Start);<br />
        }<br />
<br />
        while (master.ConnectedSlaveCount != slaveCount)<br />
            Thread.Sleep(0);<br />
<br />
        Logger.Write("Start!");<br />
        while (true)<br />
        {<br />
            master.DistributeWork(new SlaveWork());<br />
            Thread.Sleep(1000);<br />
        }<br />
    }<br />
}</pre><br />
<br />
Master를 시작하고, Slave를 10개 만들어서 Master에 연결한다.<br />
Master는 SlaveWork 객체를 만들어서 적절히 Slave에게 넘겨준다. 기본 알고리즘은 RoundRobin이므로 첫 번째 Slave부터 차례대로 일을 받게 된다.<br />
Slave는 SlaveWork를 처리한 후, 수행한 결과를 SlaveResult에 담아서 MasterWork 객체를 Master에게 전달한다.<br />
Master는 MasterWork를 받아서 그 내부에 있는 SlaveResult를 출력해준다.<br />
<br />
모두 네트워크로 전송되기 위해 SerializableAttribute를 붙이고 있다.<br />
<br />
#<br />
본 글에서는 작업을 원격지에서 수행하고, 적절히 분산시킬 수 있는 분산 처리 환경을 C#으로 간단히 구현해봤다.<br />
Master와 Slave의 코드를 한 Assembly에 넣어놨기 때문에 Serialize/Deserialize를 수행함에 있어서 아주 편했다.<br />
<br />
하지만 제대로 된 분산 환경에서 Master와 Slave가 같은 코드를 공유한다는 것은 다양한 작업/변경된 작업을 수행함에 있어서 매우 불리하다. 왜냐하면 Slave가 수행되는 머신의 바이너리가 지속적으로 교체되어야 하기 때문이다.<br />
<br />
또한 위 코드는 단순한 RPC 작업을 수행함에 있어서 너무 많은 코드를 작성해야 한다. (적어도 두 개의 Work와 하나의 Result class를 작성해야 했다.)<br />
<br />
따라서 다음 글에서는 Master/Slave가 코드를 공유하지 않아도 수행될 수 있는 구조와,<br />
RpcWork와 WorkGroup 설계를 추가하여 보다 간편한 분산 작업을 작성할 수 있도록 고민해보자.<br />
<br />
<script type="text/javascript">$('article_content_area').previous().hide();$('article_content_area').previous(1).hide();</script><br />

				</div>
                <hr>

                <!-- the comments -->
				<div id="disqus_thread"></div>
				<script type="text/javascript">
					/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
					var disqus_shortname = 'lacti'; // required: replace example with your forum shortname

					/* * * DON'T EDIT BELOW THIS LINE * * */
					(function() {
						var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
						dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
						(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
					})();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
				<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

            </div>

            <div class="col-lg-4">

                <div class="well">
					<h4>Related</h4>
					<ul>
						<li><a href="/a/분산_처리_환경_구현__1.html">분산 처리 환경 구현 #1</a> <span class="date">4. 22.</span></li>
						<li><a href="/a/분산_처리_환경_구현__3.html">분산 처리 환경 구현 #3</a> <span class="date">6. 8.</span></li>
					</ul>
                </div>
                <!-- /well -->
                <div class="well">
					<h4>Recents <a href="/" class="show-all">(all)</a></h4>
					<ul>

						<li><a href="/a/패킷_enum에_따른_packet_콜백_함수_자동생성.html">패킷 enum에 따른 packet 콜백 함수 자동생성</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴__2.html">비동기 프로그래밍 패턴 #2</a> <span class="date">11. 19.</span></li>
						<li><a href="/a/비동기_프로그래밍_패턴.html">비동기 프로그래밍 패턴</a> <span class="date">10. 9.</span></li>
						<li><a href="/a/websocket,_webRTC.html">websocket, webRTC</a> <span class="date">9. 7.</span></li>
						<li><a href="/a/여의도_스터디_정리__4.html">여의도 스터디 정리 #4</a> <span class="date">8. 26.</span></li>
						<li><a href="/a/여의도_스터디_정리__3.html">여의도 스터디 정리 #3</a> <span class="date">8. 18.</span></li>
						<li><a href="/a/여의도_스터디_과제_풀이__2.html">여의도 스터디 과제 풀이 #2</a> <span class="date">8. 12.</span></li>
					</ul>
                </div>
                <!-- /well -->
				<gcse:search></gcse:search>
            </div>
        </div>

        <hr>

        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; lacti 2014</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- JavaScript -->
    <script src="../js/jquery-1.10.2.js"></script>
    <script src="../js/bootstrap.js"></script>

	<script type='text/javascript'>
		SyntaxHighlighter.all();
	</script>

	<script>
	  (function() {
		var cx = '001870890642618183212:k8iqprsstre';
		var gcse = document.createElement('script');
		gcse.type = 'text/javascript';
		gcse.async = true;
		gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
			'//www.google.com/cse/cse.js?cx=' + cx;
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(gcse, s);
	  })();
	</script>
</body>

</html>
