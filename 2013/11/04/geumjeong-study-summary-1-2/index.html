<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="blog">
	<meta name="author" content="lacti">
	<title>금정 스터디 1, 2 정리</title>
	<link href="/css/bootstrap.css" rel="stylesheet">
	<link href="/css/markdownpad-github.css" rel="stylesheet">
	<link href="/css/syntax.css" rel="stylesheet">
	<link href="/css/blog-post.css" rel="stylesheet">
</head>
<body>
	<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
		<div class="container">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="/">#</a>
			</div>

			<!-- Collect the nav links, forms, and other content for toggling -->
			<div class="collapse navbar-collapse navbar-ex1-collapse">
				<ul class="nav navbar-nav">
					<li><a href="/about/">about</a></li>
					<li><a href="http://twitter.com/lacti/">twitter</a></li>
					<li><a href="http://github.com/lacti/">github</a></li>
					<li><a href="/atom.xml">atom</a></li>
				</ul>
			</div>
			<!-- /.navbar-collapse -->
		</div>
		<!-- /.container -->
	</nav>

	<div class="container">
				<div class="row">
			<div class="col-lg-8">
				<h1 class="page-title">금정 스터디 1, 2 정리</h1>
				<p><span class="glyphicon glyphicon-time"></span> Posted on 04 Nov 2013</p>
				<hr>
				<div class="content">
				<p><em>(한 번에 1~2시간 정도로 짧게(?) 하고 있다. 대충 accelerated c++ 책이랑 EC++ 책을 보고 있다.)</em></p>

<p>C++ 언어를 가지고 C++스럽게 프로그래밍을 해보자! 는 어떤 의미일까?<br>
다양한 의견이 있겠지만, 프로그래밍 언어는 <strong>표현력이 증가</strong>하는 쪽으로 발전한다는 관점에서 프로그래머가 C에 비해서 보다 자신의 의도를 C++ 문법으로 잘 표현할 수 있는 방법으로 프로그래밍을 하는 의미가 아닐까라고 생각한다.</p>

<p>예를 들면 define 대신에 inline, const, typedef 등을 쓰는 것처럼.</p>

<p>프로그래머가 의도를 보다 명확히 표현해야 협업하는 사람이나 미래의 나와 오해가 덜 생기고 가독성도 좋고 버그도 적고 추후 유지보수하기도 좋다.</p>

<p>패턴을 사용하여 설계하는 것도 같은 맥락에 있다고 볼 수 있는데 문제는 그녀석들이 smalltalk나 java같이 enterprise한 언어에서 탄생한 녀석들이라, C++로 구현할 때 코드가 안드로메다로 가는 경우도 있다. 따라서 같은 설계를 C++스럽게 표현하기 위해 C++ 문법에도 익숙해지고, C++ 코드도 많이 읽어봐야한다.</p>

<p>즉, C++ 문법적 기능들을 사용해서 <strong>코드는 최대한 간결하게! 의미는 명확하게!</strong> 작성하는 것을 목표로 진행하고 있다.</p>

<h3>명확한 의도</h3>

<p>명확한 의도를 전달하기 위해 기본적으로 지켜야할 규칙은 당연히 <strong>이름 잘 짓기</strong>다. 예를 들어 <code>operator ++</code> overloading 해서 빼기 연산을 수행하면 안 된다는 이야기다. 뭐 이런건 이야기할 필요도 없고.</p>

<p>모든 method를 public으로 가지는 class나 의미없는 getter/setter, 지역 함수인데 전역으로 공개된 함수 등, 해당 코드의 coverage가 비정상적으로 넓어서 그 의도를 파악하지 못하는 경우가 있을 수 있겠다. (함수 내에서 사용되는 모든 변수가 전역 변수라고 생각해보자!)</p>

<p>그러므로 객체지향이랍시고 학교에서 우리에게 주입한 <em>닥치고 class, 닥치고 getter/setter</em>의 세뇌에서 풀려나 의도에 맞는 함수와 class의 사용, 적절한 visibility를 고민해야 할 것이다.</p>

<p>그러기 위한 시작점이 static storage class이다.</p>

<h3>static storage class</h3>

<p>이야기를 이어가기 위해 <strong><a href="http://en.wikipedia.org/wiki/Translation_unit_%28programming%29">번역 단위</a></strong>에 대한 개념을 대충 알 필요가 있다. 번역단위는 컴파일러가 하나의 obj 파일을 만들어내기 위한 단위라고 보면 된다. c/c++의 경우 include한 header 파일들을 cpp에 다 복사해서 넣어놓고, 전처리기가 macro expand해주고, template engine이 template instantiation한 결과라고 보면 되겠다.</p>

<p>자, 그러면 이제 코드를 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// 전역공간</span>
<span class="k">static</span> <span class="n">MyClass</span> <span class="n">svar1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sfunc</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">MyClass</span> <span class="n">svar2</span><span class="p">;</span>
</code></pre></div>
<p><code>svar1</code>과 <code>svar2</code>가 메모리에 할당되는 시점은 언제일까? 그리고 생성자가 불리는 시점은 언제일까? 둘 다 프로그램이 시작할 때 메모리에 할당되며, 생성자는 <code>svar1</code>일 경우 프로그램 시작 시, <code>svar2</code>일 경우 해당 함수가 처음 호출될 경우에 불리게 된다. <code>svar1</code>과 <code>sfunc</code>를 보면 static을 안 붙인 것과 차이가 없다고 생각할 수 있지만, static을 붙이게 되면 다른 번역 단위에서 extern keyword로 접근할 수 없게 된다.</p>

<p>요컨데 전역 변수 대신 함수 내 static 변수, 전역 함수 대신 static 함수를 써서 해당 변수/함수의 접근 범위를 줄일 수 있고, 이는 coverage를 줄일 수 있게 해주기 때문에 코드 유지보수하기 좋아진다는 소리.</p>

<h3>visibility</h3>

<p>같은 맥락으로 public, protected, private 잘 지정하고, const 잘 붙이고, const reference 잘 쓰고, typedef 잘 걸어주는걸 습관들이자. 개인적으로 필요하다면 IN, OUT directive를 넣어주는 것도 괜찮다고는 생각함. 근데 move semantics가 있으니까 reference parameter보다는 반환으로 처리해도 괜찮을 것 같다. 그리고 메모리 관리할 대상이 아니면 const reference로 반환하고, 관리할 대상이라면 <code>shared_ptr</code>로 반환하고.</p>

<p>아무튼 등등 많이 짜고 많이 읽고 익숙해져서 의도를 명확히 표현하면 되겠다.</p>

<h3>binary_search</h3>

<p>c++스러운 프로그래밍을 하기 위한 연습 첫 번째: <code>binary search</code>를 c++스럽게 작성해보자.</p>

<p>(과정 생략 결과 공개)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Iter</span><span class="o">&gt;</span>
<span class="n">_Iter</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">_Iter</span> <span class="n">left</span><span class="p">,</span> <span class="n">_Iter</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_Iter</span> <span class="n">prevLeft</span> <span class="o">=</span> <span class="n">left</span><span class="o">++</span><span class="p">;</span>
        <span class="n">_Iter</span> <span class="n">prevRight</span> <span class="o">=</span> <span class="n">right</span><span class="o">--</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prevLeft</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="n">prevLeft</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Iter</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="n">_Iter</span> <span class="n">bsearch</span><span class="p">(</span><span class="n">_Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">_Iter</span> <span class="n">end</span><span class="p">,</span> <span class="n">_Ty</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_Iter</span> <span class="n">left</span> <span class="o">=</span> <span class="n">begin</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">_Iter</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
        <span class="n">_Ty</span> <span class="n">midValue</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">mid</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">midValue</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">midValue</span><span class="p">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">left</span> <span class="o">=</span> <span class="o">++</span><span class="n">mid</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">right</span> <span class="o">==</span> <span class="n">end</span> <span class="o">||</span> <span class="o">*</span><span class="n">left</span> <span class="o">!=</span> <span class="n">key</span> <span class="o">?</span> <span class="n">end</span> <span class="o">:</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>c++스럽게 작성해야 한다면 일단 class를 만들고 보는 경향이 있는데 이게 다 객체지향 수업에서 c++을 잘못 가르쳐서 그렇다. 뿐만 아니라 GoF design pattern같은 코드의 구현체가 워낙 enterprise하게 구현된걸 많이 봐서 일반화된 프로그래밍을 할 때 크고 아름다운 class와 interface의 조합을 구성하는 경우가 많다.</p>

<p>하지만 c++에는 template이라는 좋은 물건이 있으니 저걸로도 충분히 binary_search를 잘 구현할 수 있다.</p>

<ul>
<li>최대한 일반화하여 작성하기 위해, container가 아닌 iterator 수준으로 받을 수 있도록 구현했다. 그리고 interface는 최대한 stl algorithm을 따라했다. (그래야 프로그래머가 외울게 줄어든다!)</li>
<li>c++에는 operator overloading이 있으므로 다른 언어처럼 less_comparator 같은 추상화된 객체를 도입할 필요가 없다. 그냥 <code>&lt; 연산자</code>를 쓰자.</li>
<li>random access iterator를 쓰면 편하겠지만 일단 사용하는 연산자를 최소화하기 위해 <code>++</code>, <code>--</code>, <code>==</code>, <code>* 연산자</code>만 사용했다. 따라서 저 함수에 들어가는 iterator는 위 4개의 연산자만 있으면 된다.

<ul>
<li>key로 지정된 _Ty의 경우 &lt;, == 연산자만 있으면 된다.</li>
</ul></li>
</ul>

<p>결국 하고 싶은 이야기는, <del>c++스럽게 프로그래밍을 하기 위해서는 template을 쓰자...가 아니라</del> c++의 문법을 잘 익혀놔서 가장 적합한 문법으로 구현하자는 이야기이다. 즉, 저걸 굳이 class로 프로그래밍할 필요도 없고, 그냥 일반 함수를 써서 활용도를 축소시킬 필요도 없다는 것이다.</p>

<p>물론 더 나아가서 random access iterator에 대해서도 효율적으로 동작할 수 있도록 위 코드를 수정할 수도 있다. iterator_tag와 template의 부분 특수화를 사용하거나 함수 overloading을 사용하면 간단하게 할 수 있다. 이 부분은 EC++ 책에도 잘 나와있으니 이 글에서는 생략하도록 하겠다.</p>

<p>당연한 이야기이지만 algorithm의 <a href="http://www.cplusplus.com/reference/algorithm/binary_search/">binary_search</a>를 쓰는게 더 낫다. 이미 구현되어있는 것을 또 구현하지 않는 것이 제일 좋다! 그러므로 표준 라이브러리에 대해서는 틈틈이 알아두는게 좋다.</p>

<h3>정리</h3>

<p>코드를 간결하게, 그리고 명확하게 작성하기 위해 가작 적합한 c++ 기능을 사용하는 것은 너무나 당연한 이야기다. 앞으로 남은 한 번 혹은 두 번의 기회 동안 그 이야기를 더 진행하면서 스터디를 진행하는 친구를 세뇌시킬 생각이다.</p>

<p><a href="http://libsora.so/" title="libsora.so">if1live</a>님 방식으로 이야기하면 많이 짜고 많이 읽으면 된다. 그런데 <a href="https://twitter.com/summerlight00" title="summerlight00">summerlight</a>님처럼 표준 문서를 읽으라고는 못하겠다(나도 귀찮아서 안 읽으니까!)</p>

<h3>과제</h3>

<p>다음 이야기는 type erasure를 중심으로 진행할 예정이다.<br>
과제는 아래와 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Adapter</span><span class="o">&lt;</span><span class="kt">int</span> <span class="cm">/* return-type */</span><span class="p">,</span> <span class="kt">int</span> <span class="cm">/* 1st-arg-type */</span><span class="p">,</span> <span class="kt">int</span> <span class="cm">/* 2nd-arg-type */</span><span class="o">&gt;</span>
        <span class="n">functor1</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="mi">100</span> <span class="cm">/* 1st-arg */</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">functor1</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// 120</span>
    <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">functor1</span><span class="p">(</span><span class="mi">80</span><span class="p">);</span> <span class="c1">// 180</span>
<span class="p">}</span>
</code></pre></div>
<p>위와 같은 동작을 수행할 수 있는 Adapter class (혹은 struct)을 구현해보자.</p>

				</div>

				<div class="row">
					<div class="col-md-6">
					
						<a href="/2013/10/09/asynchronous-programming-pattern-1/" title="비동기 프로그래밍 패턴 1">&laquo; 비동기 프로그래밍 패턴 1</a>
					
					</div>
					<div class="col-md-6" style="text-align: right;">
					
						<a href="/2013/11/10/geumjeong-study-homework-2/" title="금정 스터디 2 과제 풀이">&raquo; 금정 스터디 2 과제 풀이</a>
				
					</div>
				</div>
				<hr>

				<!-- the comments -->
				<div id="disqus_container">
					<div id="disqus_thread"></div>
					<script type="text/javascript">
						var disqus_shortname = 'lacti';
						(function() {
							var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
							dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
							(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
						})();
					</script>
					<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
					<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
				</div>
			</div>

			<div class="col-lg-4 sides">
			
				<div class="well">
					<h4 class="well-title">Related Posts</a></h4>
					<ul>
					
						<li><a href="/2013/11/16/geumjeong-study-homework-3/">금정 스터디 3 과제 풀이</a> <span class="date">16 Nov 2013</span></li>
					
						<li><a href="/2013/11/10/geumjeong-study-summary-3/">금정 스터디 3 정리</a> <span class="date">10 Nov 2013</span></li>
					
						<li><a href="/2013/11/10/geumjeong-study-homework-2/">금정 스터디 2 과제 풀이</a> <span class="date">10 Nov 2013</span></li>
					
						<li><a href="/2012/01/10/implicit-interface-by-template/">template의 암시적 interface 요구</a> <span class="date">10 Jan 2012</span></li>
					
						<li><a href="/2012/01/09/inherits-template-argument/">template 인자를 상속 받기</a> <span class="date">09 Jan 2012</span></li>
					
						<li><a href="/2011/11/15/type-dispatching-by-type-trait-class/">type_t class 도입을 통한 임시 객체 없는 type 분기</a> <span class="date">15 Nov 2011</span></li>
					
					</ul>
				</div>
			

				<div class="well">
					<h4 class="well-title">Recent Posts <a href="/" class="show-all">(all)</a></h4>
					<ul>
					
						<li><a href="/2014/06/02/128-things-that-it-architect-doesn-t-do/">IT 아키텍트가 하지 말아야 할 128가지</a> <span class="date">02 Jun 2014</span></li>
					
						<li><a href="/2014/05/29/ndc14-tool-development/">팀을 구하는 툴 개발</a> <span class="date">29 May 2014</span></li>
					
						<li><a href="/2014/05/29/ndc14-the-npc-master/">THE NPCM@STER - 라이브 게임에 어울리는 스토리 텔링의 접근법</a> <span class="date">29 May 2014</span></li>
					
						<li><a href="/2014/05/29/ndc14-mobile-data-mining/">모바일 데이터 분석</a> <span class="date">29 May 2014</span></li>
					
						<li><a href="/2014/05/29/ndc14-live-methodology/">신입 프로그래머들의 고민을 통해 생각해보는 누구나 쉽게 적응할 수 있는 프로젝트 만들기</a> <span class="date">29 May 2014</span></li>
					
						<li><a href="/2014/05/29/ndc14-dungeon-and-fighter-loader-optimization/">Ndc14 Dungeon And Fighter Loader Optimization</a> <span class="date">29 May 2014</span></li>
					
					</ul>
				</div>
			</div>
		</div>

		
		<footer>
			<hr>
			<div class="row">
				<div class="col-lg-12">
					<em>&copy; 2008-2014 Jaeyoung Choi</em>
				</div>
			</div>
		</footer>
	</div>
	<!-- /.container -->

	<!-- JavaScript -->
	<script src="/js/jquery-1.10.2.js"></script>
	<script src="/js/bootstrap.js"></script>
</body>
</html>
