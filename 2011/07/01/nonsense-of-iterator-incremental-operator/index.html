<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="blog">
	<meta name="author" content="lacti">
	<title>반복자 i++과 ++i에 대한 헛소리</title>
	<link href="/css/bootstrap.css" rel="stylesheet">
	<link href="/css/markdownpad-github.css" rel="stylesheet">
	<link href="/css/syntax.css" rel="stylesheet">
	<link href="/css/blog-post.css" rel="stylesheet">
</head>
<body>
	<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
		<div class="container">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="/">#</a>
			</div>

			<!-- Collect the nav links, forms, and other content for toggling -->
			<div class="collapse navbar-collapse navbar-ex1-collapse">
				<ul class="nav navbar-nav">
					<li><a href="/about/">about</a></li>
					<li><a href="http://twitter.com/lacti/">twitter</a></li>
					<li><a href="http://github.com/lacti/">github</a></li>
					<li><a href="/atom.xml">atom</a></li>
				</ul>
			</div>
			<!-- /.navbar-collapse -->
		</div>
		<!-- /.container -->
	</nav>

	<div class="container">
				<div class="row">
			<div class="col-lg-8">
				<h1 class="page-title">반복자 i++과 ++i에 대한 헛소리</h1>
				<p><span class="glyphicon glyphicon-time"></span> Posted on 01 Jul 2011</p>
				<hr>
				<div class="content">
				<p>반복문에서 반복자를 증가시킬 때, <code>for ( ; ; i++)</code>과 <code>for ( ; ; ++i)</code>를 이야기할 때, 뭐가 빠르네 느리네 이야기가 왜 나왔을까?<br>
간단히 생각해보면, <code>i++</code>과 <code>++i</code>는 동작이 약간 다르다. 연산자 우선순위는 <code>i++</code>이 좀 더 빠르지만, 실행 측면에서 본다면</p>

<p><code>i++</code>은</p>

<ol>
<li>자신의 상태를 저장한다</li>
<li>자신의 상태를 변화한다</li>
<li>저장한 예전 상태를 반환한다</li>
</ol>

<p><code>++i</code>는</p>

<ol>
<li>자신의 상태를 변화한다</li>
<li>자신 자체를 반환한다.</li>
</ol>

<p><code>i++</code>의 3)과 <code>++i</code>의 2)를 보면 <code>i++</code>의 경우 복사해둔 것을 반환하지만, <code>++i</code>의 경우는 자기 자체(reference)를 반환한다. <code>i++++</code>은 안되지만 <code>++++i</code>는 되는 이유가 그것이다.<br>
함수 prototype으로 치자면</p>

<ul>
<li>전항연산의 <code>int &amp; operator ++ (void)</code>와 </li>
<li>후항연산의 <code>int operator ++ (int dummy)</code>의</li>
</ul>

<p>차이랄까. 반환 값의 type이 다르다.</p>

<p>이게 단순 primitive type이면서 value type일 때는, <code>i++</code>의 3)과 <code>++i</code>의 2) 가 결국 복사된 값이므로 저기서 발생하는 부담은 같지만, 이를 수행하기 위한 instruction 차이가 난다.</p>

<p>하지만 이게 wrapper class에 의한 object이면 좀 달라진다.<br>
<code>i++</code>의 경우 반환하기 위한 임시 객체를 복사해서 준비해야하고, 자신을 변화시킨 후, 복사해둔 객체를 반환해야한다. 하지만 <code>++i</code>는? 그냥 자기 자신 (*this) 을 반환하면 된다.</p>

<p>객체의 복사라는게 객체의 크기에 따라 안드로메다급으로 걸릴 수 있는 일인데다가 <code>obj next = current++;</code>와 같이 작성할 경우</p>

<ol>
<li>++ 함수 내부에서 임시 객체 생성 위한 복사 1번</li>
<li>++ 함수 반환 값에서 next 로 대입되기 위한 복사 1번</li>
<li>재수없다면 next 객체 생성 따로 ++ 함수 반환 값 대입 연산 따로 까지 칠 경우 1번</li>
</ol>

<p>총 2번 (컴파일러가 바보면 3번) 복사 짓을 해야한다는 것이다. 메모리도 그렇고 명령어도 그렇고 낭비가 심하다.</p>

<p>STL의 iterator 같은 걸 쓸 때 iterator는 object이다. 따라서 전항 ++ 이 후항 ++ 보다 성능이 빠르다는 이야기가 위 근거에 의해 성립되는 것이다.</p>

<p>자 그럼 이게 왜 헛소리인지 보자. 일단 <strong>컴파일러가 그렇게 멍청하지 않다.</strong><br>
for 문에서 int 변수를 <code>i++</code> 하나 <code>++i</code> 하나 컴파일러가 바보가 아닌 이상에야 <code>INC instruction</code> 넣어주면 된다.</p>

<p>저게 iterator 같은 class라면?</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">class</span> <span class="nc">serial</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">serial</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;prefix&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">serial</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dummy</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;postfix&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">serial</span> <span class="n">s</span><span class="p">;</span>
    <span class="o">++++</span><span class="n">s</span><span class="p">;</span>
    <span class="n">s</span><span class="o">++++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>재밌게도 후항(postfix) ++ 연산을 overloading할 때 반환 값에 대해서 신경을 쓰지 않아도 된다. 그런고로 전항(prefix) ++ 연산과 동일한 동작을 수행하게 하면 성능상 문제가 없다 할 수 있겠다.</p>

<p>물론, </p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">serial</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dummy</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div>
<p>와 같이 후항 연산에서 전항 연산을 호출해버려도 되고, (컴파일러가 함수 호출은 최적화시켜 줄거라 믿자)</p>

<p>Visual Studio 2010에서 해본 결과 아예 후항 ++ 연산 함수를 정의하지 않으면 알아서 전항 ++ 함수를 호출해버린다-_-
(g++ 4.5.2에서는 error: no &#39;operator++(int)&#39; declared for postfix &#39;++&#39; 와 같이 에러를 띄운다)</p>

<p>그런고로 값 타입이든 객체 타입이든 반복문 등에서 반복자를 증가시킬 때 ++을 앞에 쓰냐 뒤에 쓰냐는 성능에 영향이 없다는 소리. 물론 컴파일러에 따라 다를 수 있다는 말이 제일 정답일 것이다만-_-</p>

				</div>

				<div class="row page-navigator">
					<div class="col-md-6">
					
						<a href="/2011/05/21/program-segment/" title="프로그램 세그먼트">&laquo; 프로그램 세그먼트</a>
					
					</div>
					<div class="col-md-6" style="text-align: right;">
					
						<a href="/2011/07/13/generic-interface-implemented-by-template/" title="template에 의한 generic interface 정의">&raquo; template에 의한 generic interface 정의</a>
				
					</div>
				</div>
				<hr>

				<!-- the comments -->
				<div id="disqus_container">
					<div id="disqus_thread"></div>
					<script type="text/javascript">
						var disqus_shortname = 'lacti';
						(function() {
							var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
							dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
							(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
						})();
					</script>
					<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
					<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
				</div>
			</div>

			<div class="col-lg-4 sides">
			

				<div class="well">
					<h4 class="well-title">Recent Posts <a href="/" class="show-all">(all)</a></h4>
					<ul>
					
						<li><a href="/2014/06/02/128-things-that-it-architect-doesn-t-do/">IT 아키텍트가 하지 말아야 할 128가지</a> <span class="date">02 Jun 2014</span></li>
					
						<li><a href="/2014/05/29/ndc14-tool-development/">팀을 구하는 툴 개발</a> <span class="date">29 May 2014</span></li>
					
						<li><a href="/2014/05/29/ndc14-the-npc-master/">THE NPCM@STER - 라이브 게임에 어울리는 스토리 텔링의 접근법</a> <span class="date">29 May 2014</span></li>
					
						<li><a href="/2014/05/29/ndc14-mobile-data-mining/">모바일 데이터 분석</a> <span class="date">29 May 2014</span></li>
					
						<li><a href="/2014/05/29/ndc14-live-methodology/">신입 프로그래머들의 고민을 통해 생각해보는 누구나 쉽게 적응할 수 있는 프로젝트 만들기</a> <span class="date">29 May 2014</span></li>
					
						<li><a href="/2014/05/29/ndc14-dungeon-and-fighter-loader-optimization/">던전 앤 파이터 클라이언트 로딩 속도 최적화 - 우리 아이가 세배 빨라졌어요!</a> <span class="date">29 May 2014</span></li>
					
					</ul>
				</div>
			</div>
		</div>

		
		<footer>
			<hr>
			<div class="row">
				<div class="col-lg-12">
					<em>&copy; 2008-2014 Jaeyoung Choi</em>
				</div>
			</div>
		</footer>
	</div>
	<!-- /.container -->

	<!-- JavaScript -->
	<script src="/js/jquery-1.10.2.js"></script>
	<script src="/js/bootstrap.js"></script>
</body>
</html>
